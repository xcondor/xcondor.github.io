<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="前端、node、Vue、React、yoyo 洗个脑 煎饼果子来一套">
    

    <!--Author-->
    
        <meta name="author" content="xcondor">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Western honeybee">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="前端、node、Vue、React、yoyo 洗个脑 煎饼果子来一套">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Western honeybee">

    <!--Type page-->
    
        <meta property="og:type" content="website">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>page - Western honeybee</title>

    <!-- Bootstrap Core CSS -->
    <!--<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">-->

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../../css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="../../index.html">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="../../archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="../../about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="../../tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="../../categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="../../contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/xcondor.github.io/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Western honeybee</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/09/20/webpack-e6-9e-84-e5-bb-ba-e6-80-a7-e8-83-bd-e4-bc-98-e5-8c-96-1/">
                Webpack 构建性能优化
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-09-20</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.关闭source-map选项 【压缩构建文件大小，避免生成调试文件，只针对线上环境】 2. HappyPack 配置附配置 ：</p>
<pre><code>const HappyPack = require(&apos;happypack&apos;);
const ParallelUglifyPlugin = require(&apos;webpack-parallel-uglify-plugin&apos;);
module: {
        noParse: [/react\.min\.js$/, /moment\.min\.js$/],
        rules: [
            {
                test: /\.(js)$/,
                use: {
                    loader: &quot;babel-loader?cacheDirectory&quot;,
                    options: {
                        presets: [
                            &quot;es2015&quot;, &quot;react&quot;, &quot;stage-0&quot;
                        ]
                    }
                },
                exclude: /node_modules/,
            },
            {
                test: /\.(less|css)$/,
                loader: ExtractTextPlugin.extract({
                    fallback: &quot;style-loader&quot;,
                    use: [&apos;happypack/loader?id=2&apos;]
                })
            },
            {
                test: /\.(jpe?g|png|gif)$/,
                loader: &apos;url-loader?limit=8192&amp;name=images/[name].[ext]&amp;publicPath=../&apos;
            }
        ]
    },

plugins: [
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;common&apos;,
            filename: &apos;js/[name].js&apos;
        }),
        new HappyPack({
            id: &quot;1&quot;,
            threads: 8,
            loaders: [&apos;babel-loader?cacheDirectory=true&amp;presets[]=react,presets[]=es2015,presets[]=stage-0&apos;],
            verbose: true
        }),
        new HappyPack({
            id: &quot;2&quot;,
            threads: 8,
            loaders: [&quot;css-loader?modules=false&amp;sourceMap=false&amp;minimize=true&quot;, &quot;autoprefixer-loader?browsers=last 10 versions&quot;, &quot;less-loader&quot;],
            verbose: true
        }),
]</code></pre><p>3. 通过 module.noParse 忽略文件 上面有配置</p>
<pre><code>module.exports = {
  module: {
    // 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理
    noParse: [/react\.min\.js$/],
  },
};</code></pre><p>4.通过 resolve.alias 映射文件</p>
<pre><code>module.exports = {
  resolve: {
    // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，
    // 减少耗时的递归解析操作
    alias: {
      &apos;react&apos;: path.resolve(__dirname, &apos;./node_modules/react/dist/react.min.js&apos;),
    }
  },
};</code></pre><p>5. 缩小 resolve.modules 的范围</p>
<pre><code>module.exports = {
            resolve: {
                // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
                // 其中 __dirname 表示当前工作目录，也就是项目根目录
                modules: [path.resolve(__dirname, &apos;node_modules&apos;)]
         },
};</code></pre><p>6.缩小 Loader 的命中范围</p>
<pre><code>module.exports = {
  module: {
    rules: [
      {
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
        use: [&apos;babel-loader?cacheDirectory&apos;],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, &apos;src&apos;),
      },
    ]
  },
};</code></pre><p>7.缩小 resolve.extensions 的数量</p>
<pre><code>module.exports = {
  resolve: {
    // 尽可能的减少后缀尝试的可能性
    extensions: [&apos;js&apos;],
  },
};</code></pre><ol start="8">
<li>使用 DllPlugin 配置过于繁杂，未使用。其他亲测有效</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/09/20/happypack-e9-85-8d-e7-bd-ae/">
                HappyPack配置
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-09-20</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>npm install happypack --save-dev


{
                test: /\.(js)$/,
                exclude: /node_modules/,
                use:{
                    loader: &apos;happypack/loader?id=1&apos;
                }
 },

new HappyPack({
            id: &quot;1&quot;,
            threads:4,
            loaders: [&apos;babel-loader?cacheDirectory=true&amp;presets[]=react,presets[]=es2015,presets[]=stage-0&apos;],
            verbose: true
        }),</code></pre><p>确保babel-loader参数带上支持ES6 参</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/07/31/js-e5-bc-80-e5-8f-91-e5-b0-8f-e6-8a-80-e5-b7-a7/">
                JS开发小技巧
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-31</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="1-类型强制转换"><a href="#1-类型强制转换" class="headerlink" title="1. 类型强制转换"></a>1. 类型强制转换</h2><h3 id="1-1-string强制转换为数字"><a href="#1-1-string强制转换为数字" class="headerlink" title="1.1 string强制转换为数字"></a>1.1 string强制转换为数字</h3><p>可以用<code>*1</code>来转化为数字(实际上是调用<code>.valueOf</code>方法) 然后使用<code>Number.isNaN</code>来判断是否为<code>NaN</code>，或者使用 <code>a !== a</code> 来判断是否为<code>NaN</code>，因为 <code>NaN !== NaN</code></p>
<pre><code>&apos;32&apos; * 1            // 32
&apos;ds&apos; * 1            // NaN
null * 1            // 0
undefined * 1    // NaN
1  * { valueOf: ()=&gt;&apos;3&apos; }        // 3
复制代码</code></pre><p><strong>常用：</strong> 也可以使用<code>+</code>来转化字符串为数字</p>
<pre><code>+ &apos;123&apos;            // 123
+ &apos;ds&apos;               // NaN
+ &apos;&apos;                    // 0
+ null              // 0
+ undefined    // NaN
+ { valueOf: ()=&gt;&apos;3&apos; }    // 3
复制代码</code></pre><h3 id="1-2-object强制转化为string"><a href="#1-2-object强制转化为string" class="headerlink" title="1.2 object强制转化为string"></a>1.2 object强制转化为string</h3><p>可以使用 <code>字符串+Object</code> 的方式来转化对象为字符串(实际上是调用 <code>.toString()</code> 方法)</p>
<pre><code>&apos;the Math object:&apos; + Math                // &quot;the Math object:[object Math]&quot;
&apos;the JSON object:&apos; + JSON              // &quot;the JSON object:[object JSON]&quot;
复制代码</code></pre><p>当然也可以覆盖对象的<code>toString</code>和<code>valueOf</code>方法来自定义对象的类型转换：</p>
<pre><code>2  * { valueOf: ()=&gt;&apos;3&apos; }                // 6
&apos;J&apos; + { toString: ()=&gt;&apos;S&apos; }                // &quot;JS&quot;
复制代码</code></pre><blockquote>
<p>《Effective JavaScript》P11：当<code>+</code>用在连接字符串时，当一个对象既有<code>toString</code>方法又有<code>valueOf</code>方法时候，JS通过盲目使用<code>valueOf</code>方法来解决这种含糊。 对象通过<code>valueOf</code>方法强制转换为数字，通过<code>toString</code>方法强制转换为字符串</p>
</blockquote>
<pre><code>&apos;&apos; + {toString:()=&gt;&apos;S&apos;,valueOf:()=&gt;&apos;J&apos;}                // J
复制代码</code></pre><h3 id="1-3-使用Boolean过滤数组中的所有假值"><a href="#1-3-使用Boolean过滤数组中的所有假值" class="headerlink" title="1.3 使用Boolean过滤数组中的所有假值"></a>1.3 使用Boolean过滤数组中的所有假值</h3><p>我们知道JS中有一些假值：<code>false</code>，<code>null</code>，<code>0</code>，<code>&quot;&quot;</code>，<code>undefined</code>，<code>NaN</code>，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换</p>
<pre><code>const compact = arr =&gt; arr.filter(Boolean)
compact([0, 1, false, 2, &apos;&apos;, 3, &apos;a&apos;, &apos;e&apos; * 23, NaN, &apos;s&apos;, 34])             // [ 1, 2, 3, &apos;a&apos;, &apos;s&apos;, 34 ]
复制代码</code></pre><h3 id="1-4-双位运算符"><a href="#1-4-双位运算符" class="headerlink" title="1.4 双位运算符 ~~"></a>1.4 双位运算符 ~~</h3><p>可以使用双位操作符来替代 <code>Math.floor( )</code>。双否定位操作符的优势在于它执行相同的操作运行速度更快。</p>
<pre><code>Math.floor(4.9) === 4      //true
// 简写为：
~~4.9 === 4      //true
复制代码</code></pre><p>不过要注意，对整数来说 <code>~~</code> 运算结果与 <code>Math.floor( )</code> 运算结果相同，而对于负数来说不相同：</p>
<pre><code>~~4.5            // 4
Math.floor(4.5)        // 4
~~-4.5        // -4
Math.floor(-4.5)        // -5
复制代码</code></pre><h3 id="1-5-短路运算符"><a href="#1-5-短路运算符" class="headerlink" title="1.5 短路运算符"></a>1.5 短路运算符</h3><p>我们知道逻辑与<code>&amp;&amp;</code>与逻辑或<code>||</code>是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了； 可以理解为：</p>
<ul>
<li><p><code>&amp;&amp;</code>为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值</p>
</li>
<li><p><code>||</code>为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值</p>
<p>let param1 = expr1 &amp;&amp; expr2<br>let param2 = expr1 || expr2<br>复制代码</p>
</li>
</ul>
<p>运算符</p>
<p>示例</p>
<p>说明</p>
<p><code>&amp;&amp;</code></p>
<p><code>expr1&amp;&amp;expr2</code></p>
<p>如果expr1 能转换成false则返回expr1,否则返回expr2. 因此, 在Boolean环境中使用时, 两个操作结果都为true时返回true,否则返回false.</p>
<p><code>||</code></p>
<p><code>expr1||expr2</code></p>
<p>如果expr1能转换成true则返回expr1,否则返回expr2. 因此,在boolean环境(在if的条件判断中)中使用时, 二者操作结果中只要有一个为true,返回true;二者操作结果都为false时返回false.</p>
<p><code>!</code></p>
<p><code>!expr</code></p>
<p>如果单个表达式能转换为true的话返回false,否则返回true.</p>
<p>因此可以用来做很多有意思的事，比如给变量赋初值：</p>
<pre><code>let variable1
let variable2 = variable1  || &apos;foo&apos;    
复制代码</code></pre><p>如果variable1是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的<code>foo</code>。 也可以用来进行简单的判断，取代冗长的<code>if</code>语句：</p>
<pre><code>let variable = param &amp;&amp; param.prop
复制代码</code></pre><p>如果<code>param</code>如果为真值则返回<code>param.prop</code>属性，否则返回<code>param</code>这个假值，这样在某些地方防止<code>param</code>为<code>undefined</code>的时候还取其属性造成报错。</p>
<h3 id="1-6-取整-0"><a href="#1-6-取整-0" class="headerlink" title="1.6 取整 | 0"></a>1.6 取整 <code>| 0</code></h3><p>对一个数字<code>| 0</code>可以取整，负数也同样适用，<code>num | 0</code></p>
<pre><code>1.3 | 0         // 1
-1.9 | 0        // -1
复制代码</code></pre><h3 id="1-7-判断奇偶数-amp-1"><a href="#1-7-判断奇偶数-amp-1" class="headerlink" title="1.7 判断奇偶数 &amp; 1"></a>1.7 判断奇偶数 <code>&amp; 1</code></h3><p>对一个数字<code>&amp; 1</code>可以判断奇偶数，负数也同样适用，<code>num &amp; 1</code></p>
<pre><code>const num=3;
!!(num &amp; 1)                    // true
!!(num % 2)                    // true
复制代码</code></pre><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><h3 id="2-1-函数默认值"><a href="#2-1-函数默认值" class="headerlink" title="2.1 函数默认值"></a>2.1 函数默认值</h3><pre><code>func = (l, m = 3, n = 4 ) =&gt; (l * m * n);
func(2)             //output: 24
复制代码</code></pre><p>注意，传入参数为<code>undefined</code>或者不传入的时候会使用默认参数，但是传入<code>null</code>还是会覆盖默认参数。</p>
<h3 id="2-2-强制参数"><a href="#2-2-强制参数" class="headerlink" title="2.2 强制参数"></a>2.2 强制参数</h3><p>默认情况下，如果不向函数参数传值，那么JS 会将函数参数设置为<code>undefined</code>。其它一些语言则会发出警告或错误。要执行参数分配，可以使用<code>if</code>语句抛出未定义的错误，或者可以利用<code>强制参数</code>。</p>
<pre><code>mandatory = ( ) =&gt; {
  throw new Error(&apos;Missing parameter!&apos;);
}
foo = (bar = mandatory( )) =&gt; {            // 这里如果不传入参数，就会执行manadatory函数报出错误
  return bar;
}
复制代码</code></pre><h3 id="2-3-隐式返回值"><a href="#2-3-隐式返回值" class="headerlink" title="2.3 隐式返回值"></a>2.3 隐式返回值</h3><p>返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略大括号<code>{ }</code>，以便省略返回关键字）。 要返回多行语句（例如对象文本），需要使用<code>( )</code>而不是<code>{ }</code>来包裹函数体。这样可以确保代码以单个语句的形式进行求值。</p>
<pre><code>function calcCircumference(diameter) {
  return Math.PI * diameter
}
// 简写为：
calcCircumference = diameter =&gt; (
  Math.PI * diameter;
)
复制代码</code></pre><h3 id="2-4-惰性载入函数"><a href="#2-4-惰性载入函数" class="headerlink" title="2.4 惰性载入函数"></a>2.4 惰性载入函数</h3><p>在某个场景下我们的函数中有判断语句，这个判断依据在整个项目运行期间一般不会变化，所以判断分支在整个项目运行期间只会运行某个特定分支，那么就可以考虑惰性载入函数</p>
<pre><code>function foo(){
    if(a !== b){
        console.log(&apos;aaa&apos;)
    }else{
        console.log(&apos;bbb&apos;)
    }
}

// 优化后
function foo(){
    if(a != b){
        foo = function(){
            console.log(&apos;aaa&apos;)
        }
    }else{
        foo = function(){
            console.log(&apos;bbb&apos;)
        }
    }
    return foo();
}
复制代码</code></pre><p>那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。</p>
<h3 id="2-5-一次性函数"><a href="#2-5-一次性函数" class="headerlink" title="2.5 一次性函数"></a>2.5 一次性函数</h3><p>跟上面的惰性载入函数同理，可以在函数体里覆写当前函数，那么可以创建一个一次性的函数，重新赋值之前的代码相当于只运行了一次，适用于运行一些只需要执行一次的初始化代码</p>
<pre><code>var sca = function() {
    console.log(&apos;msg&apos;)
    sca = function() {
        console.log(&apos;foo&apos;)
    }
}
sca()        // msg
sca()        // foo
sca()        // foo
复制代码</code></pre><h2 id="3-代码复用"><a href="#3-代码复用" class="headerlink" title="3. 代码复用"></a>3. 代码复用</h2><h3 id="3-1-Object-key"><a href="#3-1-Object-key" class="headerlink" title="3.1 Object [key]"></a>3.1 Object [key]</h3><p>虽然将 <code>foo.bar</code> 写成 <code>foo [&#39;bar&#39;]</code> 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。许多框架使用了这种方法，比如element的<a href="https://link.juejin.im?target=http%3A%2F%2Felement-cn.eleme.io%2F%23%2Fzh-CN%2Fcomponent%2Fform%23biao-dan-yan-zheng" target="_blank" rel="noopener">表单验证</a>。 请考虑下面这个验证函数的简化示例：</p>
<pre><code>function validate(values) {
  if(!values.first)
    return false;
  if(!values.last)
    return false;
  return true;
}
console.log(validate({first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true
复制代码</code></pre><p>上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。</p>
<pre><code>// object validation rules
const schema = {
  first: {
    required:true
  },
  last: {
    required:true
  }
}

// universal validation function
const validate = (schema, values) =&gt; {
  for(field in schema) {
    if(schema[field].required) {
      if(!values[field]) {
        return false;
      }
    }
  }
  return true;
}
console.log(validate(schema, {first:&apos;Bruce&apos;})); // false
console.log(validate(schema, {first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true
复制代码</code></pre><p>现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。</p>
<h2 id="4-数字"><a href="#4-数字" class="headerlink" title="4. 数字"></a>4. 数字</h2><h3 id="4-1-不同进制表示法"><a href="#4-1-不同进制表示法" class="headerlink" title="4.1 不同进制表示法"></a>4.1 不同进制表示法</h3><p>ES6中新增了不同进制的书写格式，在后台传参的时候要注意这一点。</p>
<pre><code>29            // 10进制
035            // 8进制29      原来的方式
0o35            // 8进制29      ES6的方式
0x1d            // 16进制29
0b11101            // 2进制29
复制代码</code></pre><h3 id="4-2-精确到指定位数的小数"><a href="#4-2-精确到指定位数的小数" class="headerlink" title="4.2 精确到指定位数的小数"></a>4.2 精确到指定位数的小数</h3><p>将数字四舍五入到指定的小数位数。使用 <code>Math.round()</code> 和模板字面量将数字四舍五入为指定的小数位数。 省略第二个参数 <code>decimals</code> ，数字将被四舍五入到一个整数。</p>
<pre><code>const round = (n, decimals = 0) =&gt; Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)
round(1.345, 2)                 // 1.35
round(1.345, 1)                 // 1.3
复制代码</code></pre><h3 id="4-3-数字补0操作"><a href="#4-3-数字补0操作" class="headerlink" title="4.3 数字补0操作"></a>4.3 数字补0操作</h3><p>感谢网友 @JserWang @vczhan 提供这个小技巧 有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用<code>slice</code>和string的<code>padStart</code>方法</p>
<pre><code>const addZero1 = (num, len = 2) =&gt; (`0${num}`).slice(-len)
const addZero2 = (num, len = 2) =&gt; (`${num}`).padStart(len , &apos;0&apos;)
addZero1(3) // 03
addZero2(32,4)  // 0032
复制代码</code></pre><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="5-1-reduce方法同时实现map和filter"><a href="#5-1-reduce方法同时实现map和filter" class="headerlink" title="5.1 reduce方法同时实现map和filter"></a>5.1 reduce方法同时实现map和filter</h3><p>假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。 在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。</p>
<pre><code>const numbers = [10, 20, 30, 40];
const doubledOver50 = numbers.reduce((finalList, num) =&gt; {
  num = num * 2;
  if (num &gt; 50) {
    finalList.push(num);
  }
  return finalList;
}, []);
doubledOver50;            // [60, 80]
复制代码</code></pre><h3 id="5-2-统计数组中相同项的个数"><a href="#5-2-统计数组中相同项的个数" class="headerlink" title="5.2 统计数组中相同项的个数"></a>5.2 统计数组中相同项的个数</h3><p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。 下面的代码将统计每一种车的数目然后把总数用一个对象表示。</p>
<pre><code>var cars = [&apos;BMW&apos;,&apos;Benz&apos;, &apos;Benz&apos;, &apos;Tesla&apos;, &apos;BMW&apos;, &apos;Toyota&apos;];
var carsObj = cars.reduce(function (obj, name) {
  obj[name] = obj[name] ? ++obj[name] : 1;
  return obj;
}, {});
carsObj; // =&gt; { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }
复制代码</code></pre><h3 id="5-3-使用解构来交换参数数值"><a href="#5-3-使用解构来交换参数数值" class="headerlink" title="5.3 使用解构来交换参数数值"></a>5.3 使用解构来交换参数数值</h3><p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p>
<pre><code>let param1 = 1;
let param2 = 2;
[param1, param2] = [param2, param1];
console.log(param1) // 2
console.log(param2) // 1
复制代码</code></pre><p>当然我们关于交换数值有不少其他办法：</p>
<pre><code>var temp = a; a = b; b = temp                
b = [a, a = b][0]                         
a = a + b; b = a - b; a = a - b            
复制代码</code></pre><h3 id="5-4-接收函数返回的多个结果"><a href="#5-4-接收函数返回的多个结果" class="headerlink" title="5.4 接收函数返回的多个结果"></a>5.4 接收函数返回的多个结果</h3><p>在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。</p>
<pre><code>async function getFullPost(){
  return await Promise.all([
     fetch(&apos;/post&apos;),
     fetch(&apos;/comments&apos;)
  ]);
}
const [post, comments] = getFullPost();
复制代码</code></pre><h3 id="5-5-将数组平铺到指定深度"><a href="#5-5-将数组平铺到指定深度" class="headerlink" title="5.5 将数组平铺到指定深度"></a>5.5 将数组平铺到指定深度</h3><p>使用递归，为每个深度级别 <code>depth</code> 递减 1 。 使用 <code>Array.reduce()</code> 和 <code>Array.concat()</code> 来合并元素或数组。 基本情况下，<code>depth</code> 等于 1 停止递归。 省略第二个参数，<code>depth</code> 只能平铺到 1 (单层平铺) 的深度。</p>
<pre><code>const flatten = (arr, depth = 1) =&gt;
  depth != 1
    ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), [])
    : arr.reduce((a, v) =&gt; a.concat(v), []);
flatten([1, [2], 3, 4]);                             // [1, 2, 3, 4]
flatten([1, [2, [3, [4, 5], 6], 7], 8], 2);           // [1, 2, 3, [4, 5], 6, 7, 8]
复制代码</code></pre><h3 id="5-6-数组的对象解构"><a href="#5-6-数组的对象解构" class="headerlink" title="5.6 数组的对象解构"></a>5.6 数组的对象解构</h3><p>数组也可以对象解构，可以方便的获取数组的第n个值</p>
<pre><code>const csvFileLine = &apos;1997,John Doe,US,john@doe.com,New York&apos;;
const { 2: country, 4: state } = csvFileLine.split(&apos;,&apos;);

country            // US
state            // New Yourk
复制代码</code></pre><h2 id="6-对象"><a href="#6-对象" class="headerlink" title="6. 对象"></a>6. 对象</h2><h3 id="6-1-使用解构删除不必要属性"><a href="#6-1-使用解构删除不必要属性" class="headerlink" title="6.1 使用解构删除不必要属性"></a>6.1 使用解构删除不必要属性</h3><p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。 下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。</p>
<pre><code>let {_internal, tooBig, ...cleanObject} = {el1: &apos;1&apos;, _internal:&quot;secret&quot;, tooBig:{}, el2: &apos;2&apos;, el3: &apos;3&apos;};

console.log(cleanObject);                         // {el1: &apos;1&apos;, el2: &apos;2&apos;, el3: &apos;3&apos;}
复制代码</code></pre><h3 id="6-2-在函数参数中解构嵌套对象"><a href="#6-2-在函数参数中解构嵌套对象" class="headerlink" title="6.2 在函数参数中解构嵌套对象"></a>6.2 在函数参数中解构嵌套对象</h3><p>在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。</p>
<pre><code>var car = {
  model: &apos;bmw 2018&apos;,
  engine: {
    v6: true,
    turbo: true,
    vin: 12345
  }
}
const modelAndVIN = ({model, engine: {vin}}) =&gt; {
  console.log(`model: ${model} vin: ${vin}`);
}
modelAndVIN(car); // =&gt; model: bmw 2018  vin: 12345</code></pre><p>作者：SHERlocked93 链接：<a href="https://juejin.im/post/5b51e5d3f265da0f4861143c" target="_blank" rel="noopener">https://juejin.im/post/5b51e5d3f265da0f4861143c</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/07/26/react-e7-bb-84-e4-bb-b6-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f/">
                React 组件生命周期
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-26</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://www.xcondor.cn/wp-content/uploads/2018/07/1106982-20170811224737742-1564011484.jpg" alt></p>
<h2 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h2><p><code>object getDefaultProps()</code> 执行过一次后，被创建的类会有缓存，映射的值会存在<code>this.props</code>,前提是这个prop不是父组件指定的 这个方法在对象被创建之前执行，因此不能在方法内调用<code>this.props</code> ，另外，注意任何<code>getDefaultProps()</code>返回的对象在实例中共享，不是复制</p>
<h2 id="getInitialState"><a href="#getInitialState" class="headerlink" title="getInitialState"></a>getInitialState</h2><p><code>object getInitialState()</code> 控件加载之前执行，返回值会被用于state的初始化值</p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><p><code>void componentWillMount()</code> 执行一次，在初始化<code>render</code>之前执行，如果在这个方法内调用<code>setState</code>，<code>render()</code>知道state发生变化，并且只执行一次</p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p><code>ReactElement render()</code> render的时候会调用<code>render()</code>会被调用 调用<code>render()</code>方法时，首先检查<code>this.props</code>和<code>this.state</code>返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现 如果不想渲染可以返回null或者false，这种场景下，<a href="http://lib.csdn.net/base/react" title="React知识库" target="_blank" rel="noopener">react</a>渲染一个<code>&lt;noscript&gt;</code>标签，当返回null或者false时，<code>ReactDOM.findDOMNode(this)</code>返回null <code>render()</code>方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在<code>componentDidMount()</code>方法中实现或者其他生命周期的方法中实现，保持<code>render()</code>方法纯净使得服务器更准确，组件更简单</p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p><code>void componentDidMount()</code> 在初始化render之后只执行一次，在这个方法内，可以访问任何组件，<code>componentDidMount()</code>方法中的子组件在父组件之前执行 从这个函数开始，就可以和js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求</p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><pre><code>boolean shouldComponentUpdate(
  object nextProps, object nextState
}</code></pre><p>这个方法在初始化<code>render</code>时不会执行，当props或者state发生变化时执行，并且是在<code>render</code>之前，当新的<code>props</code>或者<code>state</code>不需要更新组件时，返回false</p>
<pre><code>shouldComponentUpdate: function(nextProps, nextState) {
  return nextProps.id !== this.props.id;
}</code></pre><p>当<code>shouldComponentUpdate</code>方法返回false时，就不会执行<code>render()</code>方法，<code>componentWillUpdate</code>和<code>componentDidUpdate</code>方法也不会被调用 默认情况下，<code>shouldComponentUpdate</code>方法返回true防止<code>state</code>快速变化时的问题，但是如果·<code>state</code>不变，<code>props</code>只读，可以直接覆盖<code>shouldComponentUpdate</code>用于比较<code>props</code>和<code>state</code>的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能</p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><pre><code>void componentWillUpdate(
  object nextProps, object nextState
)</code></pre><p>当<code>props</code>和<code>state</code>发生变化时执行，并且在<code>render</code>方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用<code>this.setState</code>来修改状态。这个函数调用之后，就会把<code>nextProps</code>和<code>nextState</code>分别设置到<code>this.props</code>和<code>this.state</code>中。紧接着这个函数，就会调用<code>render()</code>来更新界面了</p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><pre><code>void componentDidUpdate(
  object prevProps, object prevState
)</code></pre><p>组件更新结束之后执行，在初始化<code>render</code>时不执行</p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><pre><code>void componentWillReceiveProps(
  object nextProps
)</code></pre><p>当<code>props</code>发生变化时执行，初始化<code>render</code>时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用<code>this.setState()</code>来更新你的组件状态，旧的属性还是可以通过<code>this.props</code>来获取,这里调用更新状态是安全的，并不会触发额外的<code>render</code>调用</p>
<pre><code>componentWillReceiveProps: function(nextProps) {
  this.setState({
    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount
  });
}</code></pre><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p><code>void componentWillUnmount()</code> 当组件要被从界面上移除的时候，就会调用<code>componentWillUnmount()</code>,在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/07/26/e5-9b-be-e7-89-87-e5-9c-a8div-e4-b8-ad-e7-ad-89-e6-af-94-e7-bc-a9-e6-94-be/">
                图片在div中等比缩放
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-26</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>width: auto;
height: auto;
max-width: 100%;
max-height: 100%;</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/07/26/gitignore-e6-96-87-e4-bb-b6-e6-97-a0-e6-b3-95-e5-bf-bd-e7-95-a5-e7-9a-84-e9-97-ae-e9-a2-98/">
                gitignore 文件无法忽略的问题
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-26</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>git rm -r --cached .
git add .
git commit -m &apos;update .gitignore&apos;</code></pre><p>提示： 第一句命令会将所有的追踪缓存全部清除，重新add，不要因为一片的绿色害怕，go on</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/07/24/object-assign-e6-96-b9-e6-b3-95/">
                Object.assign() 方法
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-24</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<pre><code>const object1 = {
  a: 1,
  b: 2,
  c: 3
};

const object2 = Object.assign({c: 4, d: 5}, object1);

console.log(object2.c, object2.d);
// expected output: 3 5


Object.assign(target, ...sources)</code></pre><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 <code>Object.assign</code> 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" title="Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptor()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a> 。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" title="此页面仍未被本地化, 期待您的翻译!" target="_blank" rel="noopener"><code>String</code></a>类型和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。" target="_blank" rel="noopener"><code>Symbol</code>](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol “Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。”) 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" title="TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。" target="_blank" rel="noopener"><code>TypeError</code></a>，如果在引发错误之前添加了任何属性，则可以更改<code>target</code>对象。 注意，<code>Object.assign</code> 不会跳过那些值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" title="值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。" target="_blank" rel="noopener"><code>null</code></a> 或 [<code>undefined</code></a> 的源对象。</p>
<pre><code>var obj = { a: 1 };
var copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }</code></pre><p><strong>针对深拷贝，需要使用其他方法，因为 <code>Object.assign()</code>拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</strong></p>
<pre><code>function test() {
  &apos;use strict&apos;;

  let obj1 = { a: 0 , b: { c: 0}};
  let obj2 = Object.assign({}, obj1);
  console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

  obj1.a = 1;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
  console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

  obj2.a = 2;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
  console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}

  obj2.b.c = 3;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}
  console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}

  // Deep Clone
  obj1 = { a: 0 , b: { c: 0}};
  let obj3 = JSON.parse(JSON.stringify(obj1));
  obj1.a = 4;
  obj1.b.c = 4;
  console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
}

test();</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/06/23/nodejs-request-e6-a8-a1-e5-9d-97/">
                nodejs request模块
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-06-23</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>npm install --save request
get方法：
var request = require(&apos;request&apos;);
request(&apos;您的请求url&apos;, function (error, response, body) {
  if (!error &amp;&amp; response.statusCode == 200) {
    console.log(body) // 请求成功的处理逻辑
  }
});
post方法：

var request = require(&apos;request&apos;);
var url=&quot;请求url&quot;;
var requestData=&quot;上送的数据&quot;;
request({
    url: url,
    method: &quot;POST&quot;,
    json: true,
    headers: {
        &quot;content-type&quot;: &quot;application/json&quot;,
    },
    body: JSON.stringify(requestData)
}, function(error, response, body) {
    if (!error &amp;&amp; response.statusCode == 200) {
        console.log(body) // 请求成功的处理逻辑
    }
}); 
post form：

request.post({url:&apos;&apos;, form:{key:&apos;value&apos;}}, function(error, response, body) {
    if (!error &amp;&amp; response.statusCode == 200) {
       console.log(body) // 请求成功的处理逻辑  
    }
})</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/04/12/vue-e5-bc-80-e5-8f-91-e6-8c-87-e5-af-bc-e6-8f-90-e7-a4-ba-1/">
                VUE开发指导提示
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-12</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1. 安装nodejs javascript 前端平台 2. 安装 npm 包管理工具 3. 安装 webpack 命令： npm install -g webpack （全局安装）| npm install webpack –save-dev (安装在本地目录的开发环境下) 也可以用包管理工具yarn 用法基本一样。速度快。 4. 如果需要起小型服务器 npm install http-server -g 在对应的目录下 http-server -cors （支持跨域参数）就可以启动服务进行静态服务开发 对vue总结： 简单来说vue是把前端资源 （ dom 结构 + js 交互操作、数据请求 + css 样式 ）打成一个包module（js） 相对应的需要一些loader器去解释它，所以在装vue后，使用less、sass、或者各种模板引擎语法，就必须安装相关的loader才能解释。安装方法一样是npm install style-loader 类似的命令 5. vuejs //vuejs.org/zh-cn/ 使用可以直接引入来练习，但是完全vue开发还是要用相关生态 以上几个是基本的平台—包安装—前端资源构建打包工具。 因打包工具种类过多，选择还是最多的webpack 附一些经常用到的官网地址： <a href="http://xcondor.cn/nav.html" target="_blank" rel="noopener">http://xcondor.cn/nav.html</a> 首先构建一个项目目录如下: project -src //开发目录 -mock // 模拟数据 <a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a> 动态模拟后台数据，使前端模拟真实数据。相关文章推荐： <a href="https://www.cnblogs.com/zhenfei-jiang/p/7235339.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhenfei-jiang/p/7235339.html</a> -assets //静态资源 -libs //公共库 -locale //国际化文件夹 -router // 路由 <a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a> -store //vuex状态机 参阅 <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/</a> -common //公共文件-库 -views –home //首页 –error-page //错误页面 … …按照类目名称、项目结构定义显示层模块 login.vue app.vue // 主模板 <strong>* main.js // 入口文件 所有的依赖使用vue注入公共路由注入公共文件注入都在此文件 *</strong> ——————————————————— package.json 目录建好后利用npm init 创建初始化文件 <strong>* 安装了一些常用依赖的东西，会在这个文件中生成相应安装的版本和组件列表 拿到现成项目启动npm install的时候，就是根据这个配置文件去安装相应的依赖。 ——————————————————— .babelrc // babel解释器 把ES6解析成ES2015或者兼容版本的JAVASCRIPT .editorconfig //IDE设置规范，包括tab缩进字节等 .eslintignore //放弃eslint代码检查校验文件 .gitignore // git 忽略文件 把不需要的文件忽略掉 —————————————————— .jsjint // js语法检测配置 安装它为了检测js语法 前期可忽略 .eslint // 代码检查配置 安装它是为了规范代码风格 前期可忽略 /////////////////////////////////////////////////////////////////// 储备知识顺序 ES6 (JAVASCRIPT新规范、很多浏览器不支持，但是是趋势。不过babel可以将es2015解析，最好是学习) ** VUE *</strong> 必须 WEBPACK <strong>* 所有应用必须 VUEROUTER ** 大型应用必须 VUEX ** 大型应用必须 IVIEW * UI框架 次要 /</strong>备注<strong>/ *</strong> 很重要 ** 一般重要 * 重要 /** 项目参考 **/ <a href="https://github.com/xcondor/vue-admin" target="_blank" rel="noopener">https://github.com/xcondor/vue-admin</a> <a href="https://github.com/xcondor/vue2-elm" target="_blank" rel="noopener">https://github.com/xcondor/vue2-elm</a> 大型应用 <a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">https://github.com/iview/iview-admin</a> iview 后台应用 <a href="https://github.com/devjin0617/vue2-admin-lte" target="_blank" rel="noopener">https://github.com/devjin0617/vue2-admin-lte</a> <a href="https://github.com/lanux/Vue-Admin" target="_blank" rel="noopener">https://github.com/lanux/Vue-Admin</a> <a href="https://github.com/lss5270/vue-admin-spa" target="_blank" rel="noopener">https://github.com/lss5270/vue-admin-spa</a> 单页面应用   按照这个思路走，少走很多弯路。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="../../2018/03/27/charles-e5-9c-a8-e7-ba-bf-e7-a0-b4-e8-a7-a3/">
                Charles 在线破解
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-27</span>
            
            
            
                <span class="category">
                    <a href="/xcondor.github.io/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><a href="https://www.zzzmode.com/mytools/charles/" target="_blank" rel="noopener">https://www.zzzmode.com/mytools/charles/</a></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/xcondor.github.io/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/xcondor.github.io/page/3/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="../../2019/09/26/regExp表达式/">regExp表达式 [javascript]</a>
            </li>
            
            <li>
                <a class="footer-post" href="../../2019/09/26/git 不常用记录/">git.md</a>
            </li>
            
            <li>
                <a class="footer-post" href="../../2019/04/26/e6-95-b0-e7-bb-84-e5-af-b9-e8-b1-a1-e6-8e-92-e5-ba-8f-e6-8c-89-e7-85-a7jsonarray-e6-8e-92-e5-ba-8f/">数组对象排序按照JSONarray排序</a>
            </li>
            
            <li>
                <a class="footer-post" href="../../2019/04/15/e5-89-8d-e7-ab-af-e7-ae-97-e6-b3-95/">前端算法</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="../../categories/记录/转载/">转载</a>
        </li>
        
        <li>
            <a class="footer-post" href="../../categories/tutu/">tutu</a>
        </li>
        
        <li>
            <a class="footer-post" href="../../categories/迁移/">迁移</a>
        </li>
        
        <li>
            <a class="footer-post" href="../../categories/广告/">广告</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:xcondor@gmail.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="../../js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>