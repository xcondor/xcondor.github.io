<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="一个追求极致编码的中青年">
    

    <!--Author-->
    
        <meta name="author" content="xcondor">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Western honeybee">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="一个追求极致编码的中青年">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Western honeybee">

    <!--Type page-->
    
        <meta property="og:type" content="website">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>page - Western honeybee</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Western honeybee</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/05/e7-bb-9f-e8-ae-a1github-e4-b8-8a-e4-b8-80-e4-ba-9b-e7-89-9b-e9-80-bc-e7-9a-84-e5-bc-80-e6-ba-90-e9-a1-b9-e7-9b-ae/">
                统计github上一些牛逼的开源项目
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-05</span>
            
            
            
                <span class="category">
                    <a href="/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>anyupload: https://github.com/dianbaer/anyupload
该项目是一款上传插件，使用方便、简单。支持多文件上传、上传速率动态控制、真实进度监控 kb/s、分块生成 MD5、分块上传、MD5 校验、暂停、取消等功能。</code></pre><p><a href="https://www.threecss.com/AnyUploadClient/" target="_blank" rel="noopener"> 在线体验 </a></p>
<pre><code>webster: https://github.com/zhuyingda/webster
一款可以抓取网页中 AJAX 异步内容的分布式爬虫框架 


https://github.com/wearehive/project-guidelines/blob/master/README-zh.md

JavaScript 项目规范

H5  https://github.com/answershuto/H5
这是作者的个人项目，功能是可视化编辑、生成手机 H5 页面的单页应用 WebApp。该项目是一个全栈项目，具有前后端完整服务。并且项目结构清晰。后端服务具有控制器，模型，路由，前端服务具有组件，并且使用 Vuex 做状态管理，麻雀虽小五脏俱全

React 全家桶学习
React-Cnode
https://github.com/Juliiii/React-Cnode

学习angluar4
https://github.com/linguowei/micro-note

手机数字键盘：

numeric-keyboard ： https://github.com/viclm/numeric-keyboard

parrot-mocker-web： https://github.com/chinesedfan/parrot-mocker-web
小巧的 mock 服务器，配合 Chrome 插件可以轻松地拦截或 mock 页面上的 xhr/jsonp/fetch 请求。不需要侵入页面本身代码，让前端同学在后端接口没有 ready 或者难以模拟数据的时候，继续开心地开发玩耍 

小程序营销组件：
https://github.com/o2team/wxapp-market
小程序营销组件，使用简单、方式齐全。包含示例代码，玩法多样
大转盘
刮刮乐
老虎机
水果机
...

xdomain: https://github.com/jpillora/xdomain
纯js实现的xcross的库


手动实现MVVM ： https://github.com/DMQ/mvvm

基于docker控制台的工具：https://github.com/pipiliang/docker-dashboard
docker-dashboard：

中文网页重设和排版：
https://typo.sofi.sh/


VUE2.0 lol练手项目：https://github.com/arronf2e/Vue2.0LOL

http://js8.in/nodeppt/#50 网页ppt

https://github.com/ksky521/nodeppt</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/04/mockjs-e6-a1-88-e4-be-8b-e6-94-b6-e9-9b-86/">
                MockJS 案例收集
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>扩展功能：</p>
<pre><code>var Random = Mock.Random;
    Random.extend({
        weekday: function(date) {
            var weekdays = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;];
            return this.pick(weekdays);
        },
        sex: function(date) {
            var sexes = [&apos;male&apos;, &apos;female&apos;, &apos;middle&apos;, &apos;none&apos;];
            return this.pick(sexes);
        },
        money: function(n){
            var b=parseInt(n).toString();
            var len=b.length;
            if(len&lt;=3){return b;}
            var r=len%3;
            return r&gt;0?b.slice(0,r)+&quot;,&quot;+b.slice(r,len).match(/\d{3}/g).join(&quot;,&quot;):b.slice(r,len).match(/\d{3}/g).join(&quot;,&quot;);
        }
    });
    Mock.mock(&apos;http://test.com&apos;,{
            &apos;id|+1&apos;: &apos;@guid&apos;,    // 属性值自动加 1，初始值为88
            &apos;name&apos;: &apos;@cname&apos;,  // 中文名称 
            &apos;appStream|1&apos;:[&apos;500M&apos;,&apos;1G&apos;,&apos;2G&apos;,&apos;3G&apos;],//数组取其中一个
            &apos;cashBack&apos;:Random.money(100000000), //金额格式化
            &apos;tax&apos;:&apos;@INTEGER(1,100)%&apos;, //百分比
            &apos;dollar|1-100000000.2&apos;: 1.0,//金额 
            &apos;gendor&apos;:&apos;@sex&apos;,//性别
            &apos;week&apos;:&apos;@weekday&apos;, //星期
            &apos;birthday&apos;: &apos;@date(&quot;yyyy-MM-dd&quot;)&apos;, // 日期 
            &apos;city&apos;: &apos;@city(true)&apos;, // 中国城市 
            &apos;color&apos;: &apos;@color&apos;, // 16进制颜色 
            &apos;isMale|1&apos;: true, // 布尔值 
            &apos;isFat|1-2&apos;: true, // true的概率是1/3
             email:Mock.mock(&apos;@EMAIL()&apos;), //随机生成一个邮箱
            &apos;moblie|1&apos;:[&apos;13531544954&apos;,&apos;13632250649&apos;,&apos;15820292420&apos;,&apos;15999905612&apos;], //在数组中随机找一个,
            &apos;mobile2&apos;: /^1[0-9]{10}$/
})</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/04/mockjs-e6-a1-88-e4-be-8b-e6-94-b6-e9-9b-86-1/">
                MockJS 案例收集
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/记录/">记录</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>扩展功能：</p>
<pre><code>var Random = Mock.Random;
    Random.extend({
        weekday: function(date) {
            var weekdays = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;];
            return this.pick(weekdays);
        },
        sex: function(date) {
            var sexes = [&apos;male&apos;, &apos;female&apos;, &apos;middle&apos;, &apos;none&apos;];
            return this.pick(sexes);
        },
        money: function(n){
            var b=parseInt(n).toString();
            var len=b.length;
            if(len&lt;=3){return b;}
            var r=len%3;
            return r&gt;0?b.slice(0,r)+&quot;,&quot;+b.slice(r,len).match(/\d{3}/g).join(&quot;,&quot;):b.slice(r,len).match(/\d{3}/g).join(&quot;,&quot;);
        }
    });
    Mock.mock(&apos;http://test.com&apos;,{
            &apos;id|+1&apos;: &apos;@guid&apos;,    // 属性值自动加 1，初始值为88
            &apos;name&apos;: &apos;@cname&apos;,  // 中文名称 
            &apos;appStream|1&apos;:[&apos;500M&apos;,&apos;1G&apos;,&apos;2G&apos;,&apos;3G&apos;],//数组取其中一个
            &apos;cashBack&apos;:Random.money(100000000), //金额格式化
            &apos;tax&apos;:&apos;@INTEGER(1,100)%&apos;, //百分比
            &apos;dollar|1-100000000.2&apos;: 1.0,//金额 
            &apos;gendor&apos;:&apos;@sex&apos;,//性别
            &apos;week&apos;:&apos;@weekday&apos;, //星期
            &apos;birthday&apos;: &apos;@date(&quot;yyyy-MM-dd&quot;)&apos;, // 日期 
            &apos;city&apos;: &apos;@city(true)&apos;, // 中国城市 
            &apos;color&apos;: &apos;@color&apos;, // 16进制颜色 
            &apos;isMale|1&apos;: true, // 布尔值 
            &apos;isFat|1-2&apos;: true, // true的概率是1/3
             email:Mock.mock(&apos;@EMAIL()&apos;), //随机生成一个邮箱
            &apos;moblie|1&apos;:[&apos;13531544954&apos;,&apos;13632250649&apos;,&apos;15820292420&apos;,&apos;15999905612&apos;], //在数组中随机找一个,
            &apos;mobile2&apos;: /^1[0-9]{10}$/
})</code></pre>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/e5-a6-82-e4-bd-95-e5-87-8f-e5-b0-91-e7-bd-91-e9-a1-b5-e7-9a-84-e5-86-85-e5-ad-98-e4-b8-8ecpu-e5-8d-a0-e7-94-a8-1/">
                如何减少网页的内存与CPU占用
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/迁移/">迁移</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>有的网页看起来并不大但打开会很卡，有的网页虽然很长但使用流畅，占用用户电脑的内存与CPU就影响这些。 浏览器问题，有各自的浏览器处理内存问题会影响到，但几乎没办法控制得了，Windows上的：</p>
<ul>
<li>IE系列，刷新回收的量不大，但最小化会释放内存，。</li>
<li>Firefox2据说也会在最小化回收，可我从没见过最垃圾，用多少是多少，基本不回收。据说prototype的ajax还会引起内存一直增加。</li>
<li>Opera最好。一直控制得很好。不存在什么问题。。</li>
</ul>
<p>Linux的内存分配机制与Win的不一样，有多少用多少，如果浏览器占光时说不定会干掉系统。 页面问题，浏览器渲染页面会消耗内存和CPU，能减少一点就减少点。 结构上</p>
<ul>
<li>使用DocType，告诉浏览器你在用什么，html4也有DTD。也许Transitional更适合你</li>
<li>如果使用的是XHTML并能保持良好结构的话，记得输出相应的MIME跟XML头，可以减少浏览器的代码检查，</li>
<li>保持结构的完整，不要让浏览器帮你补全代码。</li>
<li>控制页面的文件大小，可以通过程序把为了看代码比较舒服的缩进去掉。2~3K也是大小。</li>
<li>iframe会产生新的页面，其实有很多方式可以代替iframe</li>
<li>引入的JS与CSS可以适当合并，同样背景图片也可以合并，甚至有人连Flash都合并</li>
<li>给已知宽高的内容图片/Object加上宽度的属性可以减少页面的局部重渲染</li>
</ul>
<p>表现上</p>
<ul>
<li>质量99跟70的jpg在大多数情况下只有文件有大小不一样。gif的也一样，特别是小图标，256色跟128色的差别是文件大小．</li>
<li>flash动得太快吃CPU很大，控制每秒的帧数及动画的效果可以减少一些，如果把品质用中低显示会省很多资源，但这样却牺牲了效果。。quality属性 有时选择Autolow 或者Autohigh会更适合，没必要一直low 或者best，</li>
<li>flash使用矢量图会节省文件大小，但计算复杂的图形跟动画时花的是CPU。复杂的太多滤镜，则会占用大量内存，模糊滤镜有减少些。</li>
<li>IE的滤镜也是比较占用内存，同时也有兼容性问题。全屏的半透明很吃资源的。</li>
<li>2*2的图片跟8*8的图片大小差不多，但是平铺背景2*2却占用大很多。</li>
<li>gif动画同样有帧的概念，别把gif当成flash来玩就行。</li>
</ul>
<p>行为上</p>
<ul>
<li>别为了使用一个$()引入整个prototype或jQuery，它们有更多的作用。</li>
<li>AJAX很帅。但是用xml会用上XML解析器，有人推荐用JSON，可是这样要eval数据，其实可以直接import已经是对象的script来用。只是要多传个对象名，或者把对象名写死，或者像flickr那样<code>jsonFlickrApi({&quot;xxx&quot;:&quot;xxx&quot;})</code>，直接当函数用，挖哈哈。</li>
<li>实现某些效果时能用<code>visibility:hidden</code>解决时就别用<code>display:none</code>来玩。</li>
<li>在这里强调js变量要注全局跟局部等等的意义并不大，JS复杂的地方也不是一两句能说得清的，关注大家关注月影的正在出版的新书吧。^^</li>
</ul>
<p>其实这里有的内容有不少跟<a href="http://www.aoao.org.cn/blog/2007/06/how-to-show-our-pages-quickly/" target="_blank" rel="noopener">如何快速的呈现我们的网页</a>相近，不过那篇是以处理服务端为主，但在很多时候，节省服务端资源消耗的同时也会节省客户端的资源消耗。 再其实，这篇已经蹲在草稿箱里好久了，一直没有时间去整理。现在给的也不是完整的，因为没有完整，慢慢补充吧。</p>
<ol>
<li>产生问题：虽然会引起<a href="http://www.aoao.org.cn/blog/2007/01/browser-mode/" title="浏览器的模式问题 Quirks Mode vs Standards Mode" target="_blank" rel="noopener">浏览器的模式问题</a>，但问题是可以解决滴。参考<a href="http://keystonewebsites.com/articles/mime_type.php" target="_blank" rel="noopener">Serving up XHTML with the correct MIME type</a>，派送XML头浏览器不会容错显示，出现错误结构会导致整个页面无法显法。</li>
<li>Autolow: 优先考虑速度，但是也会尽可能改善外观。 回放开始时，消除锯齿功能处于关闭状态。 如果 Flash Player 检测到处理器可以处理消除锯齿功能，就会打开该功能。 Autohigh:开始时回放速度和外观两者并重，必要时会牺牲外观来保证回放速度。 回放开始时，消除锯齿功能处于打开状态。如果实际帧频降到指定帧频之下，就会关闭消除锯齿功能以提高回放速度。使用此设置可模拟“消除锯齿”命令（“视图”&gt;“预览模式”&gt;“消除锯齿”）。</li>
<li>模糊滤镜:使用模糊滤镜时，如果用于 blurX 和 blurY 的值是 2 的整数次幂（例如 2、4、8、16 和 32），则可以加快计算速度，并且可以使性能提高 20% 到 30%（flash的帮助是介样说滴）。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/e5-a6-82-e4-bd-95-e5-87-8f-e5-b0-91-e7-bd-91-e9-a1-b5-e7-9a-84-e5-86-85-e5-ad-98-e4-b8-8ecpu-e5-8d-a0-e7-94-a8/">
                如何减少网页的内存与CPU占用
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/迁移/">迁移</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>有的网页看起来并不大但打开会很卡，有的网页虽然很长但使用流畅，占用用户电脑的内存与CPU就影响这些。 浏览器问题，有各自的浏览器处理内存问题会影响到，但几乎没办法控制得了，Windows上的：</p>
<ul>
<li>IE系列，刷新回收的量不大，但最小化会释放内存，。</li>
<li>Firefox2据说也会在最小化回收，可我从没见过最垃圾，用多少是多少，基本不回收。据说prototype的ajax还会引起内存一直增加。</li>
<li>Opera最好。一直控制得很好。不存在什么问题。。</li>
</ul>
<p>Linux的内存分配机制与Win的不一样，有多少用多少，如果浏览器占光时说不定会干掉系统。 页面问题，浏览器渲染页面会消耗内存和CPU，能减少一点就减少点。 结构上</p>
<ul>
<li>使用DocType，告诉浏览器你在用什么，html4也有DTD。也许Transitional更适合你</li>
<li>如果使用的是XHTML并能保持良好结构的话，记得输出相应的MIME跟XML头，可以减少浏览器的代码检查，</li>
<li>保持结构的完整，不要让浏览器帮你补全代码。</li>
<li>控制页面的文件大小，可以通过程序把为了看代码比较舒服的缩进去掉。2~3K也是大小。</li>
<li>iframe会产生新的页面，其实有很多方式可以代替iframe</li>
<li>引入的JS与CSS可以适当合并，同样背景图片也可以合并，甚至有人连Flash都合并</li>
<li>给已知宽高的内容图片/Object加上宽度的属性可以减少页面的局部重渲染</li>
</ul>
<p>表现上</p>
<ul>
<li>质量99跟70的jpg在大多数情况下只有文件有大小不一样。gif的也一样，特别是小图标，256色跟128色的差别是文件大小．</li>
<li>flash动得太快吃CPU很大，控制每秒的帧数及动画的效果可以减少一些，如果把品质用中低显示会省很多资源，但这样却牺牲了效果。。quality属性 有时选择Autolow 或者Autohigh会更适合，没必要一直low 或者best，</li>
<li>flash使用矢量图会节省文件大小，但计算复杂的图形跟动画时花的是CPU。复杂的太多滤镜，则会占用大量内存，模糊滤镜有减少些。</li>
<li>IE的滤镜也是比较占用内存，同时也有兼容性问题。全屏的半透明很吃资源的。</li>
<li>2*2的图片跟8*8的图片大小差不多，但是平铺背景2*2却占用大很多。</li>
<li>gif动画同样有帧的概念，别把gif当成flash来玩就行。</li>
</ul>
<p>行为上</p>
<ul>
<li>别为了使用一个$()引入整个prototype或jQuery，它们有更多的作用。</li>
<li>AJAX很帅。但是用xml会用上XML解析器，有人推荐用JSON，可是这样要eval数据，其实可以直接import已经是对象的script来用。只是要多传个对象名，或者把对象名写死，或者像flickr那样<code>jsonFlickrApi({&quot;xxx&quot;:&quot;xxx&quot;})</code>，直接当函数用，挖哈哈。</li>
<li>实现某些效果时能用<code>visibility:hidden</code>解决时就别用<code>display:none</code>来玩。</li>
<li>在这里强调js变量要注全局跟局部等等的意义并不大，JS复杂的地方也不是一两句能说得清的，关注大家关注月影的正在出版的新书吧。^^</li>
</ul>
<p>其实这里有的内容有不少跟<a href="http://www.aoao.org.cn/blog/2007/06/how-to-show-our-pages-quickly/" target="_blank" rel="noopener">如何快速的呈现我们的网页</a>相近，不过那篇是以处理服务端为主，但在很多时候，节省服务端资源消耗的同时也会节省客户端的资源消耗。 再其实，这篇已经蹲在草稿箱里好久了，一直没有时间去整理。现在给的也不是完整的，因为没有完整，慢慢补充吧。</p>
<ol>
<li>产生问题：虽然会引起<a href="http://www.aoao.org.cn/blog/2007/01/browser-mode/" title="浏览器的模式问题 Quirks Mode vs Standards Mode" target="_blank" rel="noopener">浏览器的模式问题</a>，但问题是可以解决滴。参考<a href="http://keystonewebsites.com/articles/mime_type.php" target="_blank" rel="noopener">Serving up XHTML with the correct MIME type</a>，派送XML头浏览器不会容错显示，出现错误结构会导致整个页面无法显法。</li>
<li>Autolow: 优先考虑速度，但是也会尽可能改善外观。 回放开始时，消除锯齿功能处于关闭状态。 如果 Flash Player 检测到处理器可以处理消除锯齿功能，就会打开该功能。 Autohigh:开始时回放速度和外观两者并重，必要时会牺牲外观来保证回放速度。 回放开始时，消除锯齿功能处于打开状态。如果实际帧频降到指定帧频之下，就会关闭消除锯齿功能以提高回放速度。使用此设置可模拟“消除锯齿”命令（“视图”&gt;“预览模式”&gt;“消除锯齿”）。</li>
<li>模糊滤镜:使用模糊滤镜时，如果用于 blurX 和 blurY 的值是 2 的整数次幂（例如 2、4、8、16 和 32），则可以加快计算速度，并且可以使性能提高 20% 到 30%（flash的帮助是介样说滴）。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/jquery-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-10-e4-ba-8b-e4-bb-b6-e5-a4-84-e7-90-86-event-dom-ready/">
                jQuery源码分析-10事件处理-Event-DOM-ready
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>作者：nuysoft/JS攻城师/高云　QQ：47214707　EMail：nuysoft@gmail.com    
声明：本文为原创文章，如需转载，请注明来源并保留原文链接。     
后文预告：封装事件对象 便捷接口解析  

前记：  
这一章写的很用心，希望有所启发。因为排版的原因，阅读附件PDF更方便一些。  

jQuery源码分析系列大概已经写了60%，架构、构建jQuery对象、异步队列、浏览器测试、数据缓存、队列、事件模型、AJAX、动画、尺寸大小基本完结，这些比较难读也是我感兴趣的，剩余的部分有选择器、DOM遍历和操作、CSS和部分章节的补充，jQuery中的正则分析已有初稿但是内容太庞大还在拿捏怎么写合适，一些章节写的不是很满意有时间会做修改，详细的目录和计划可以去目录页参看 http://nuysoft.iteye.com/blog/1190542。  

JavaScript同其他语言一样，基础非常重要，仅仅会用框架和工具写一些WebApp是不能成为一名合格的JS工程师的，建议多读几次JavaScript权威指南，以我的经验与Java相比，JavaScript需要花费与Java相当的时间才能达到与Java相当的水平。  

jQuery完结之后计划写Java开源框架的源码解析，从Spring、Hibernate开始，有兴趣的同学可以一起研究。 

10.8    DOM ready  

初学jQuery时，很可能学到的第一个知识点就是.ready()，但是网络上流转的文章和API对此的解释或剖析，经常是模棱两可甚至是不准确或错误的，本节将详细的阐述.ready()的用法和原理，并纠正这些误区。  

10.8.1  如何使用.ready()  

.ready() 指定一个事件句柄，当DOM完全加载完成时执行  

虽然JavaScript提供了load事件，当页面渲染完成之后会执行这个函数，在所以元素加载完成之前，这个函数不会被调用，例如图像。但是在大多数情况下，只要DOM结构加载完，脚本就可以尽快运行。传递给.ready()的事件句柄在DOM准备好后立即执行，因此通常情况下，最好把绑定事件句柄和其他jQuery代码都到这里来。但是当脚本依赖于CSS样式属性时，一定要在脚本之前引入外部样式或内嵌样式的元素。  

如果代码依赖于需加载完的元素（例如，想获取一个图片的尺寸大小），应该用.load()事件代替，并把代码放到load事件句柄中。  

.ready()方法不同于&lt;body onload=&quot;&quot;&gt;属性。如果必须用load事件，那么就不要使用.ready()，或用.load()代替，把load事件句柄绑定到window或其他的具体元素上，例如图片。  

以下三个语法全部是等价的：  
$(document).ready(handler)  
$().ready(handler) (this is not recommended)  
$(handler)  

$(document).bind(&quot;ready&quot;, handler)的行为类似于ready方法，但有一个例外：如果ready事件已触发后，再尝试用.bind(&quot;ready&quot;)绑定的处理函数将不会被执行。而用以上三种方法绑定的句柄会被执行，无论是什么时候绑定的。  
.ready()方法只能在包含了document的jQuery上调用，因此选择器可以省略。  
.ready()方法典型的用法是使用一个匿名函数：  
$(document).ready(function() {  
  // Handler for .ready() called.  
});  
等价于：  
$(function() {  
 // Handler for .ready() called.  
});  

如果在DOM加载完毕之后调用.ready()，新的句柄将会立即执行。  

特别强调两点：  
1.  之所以花费篇幅来阐述.ready()如何使用（翻译的官网文档），是因为网络上的一些文章和中文API不准确甚至是错误的（应该是工具翻译的），所以需谨慎参考  
2.  .ready()的触发要早于.load()，但是不要完全迷信依赖，如果要获取或操作样式，或依赖于像图片这样的必须加载完成才能获取和操作的元素，就用&lt;body onload=&quot;&quot;&gt;或.load()  

10.8.2  源码分析  

到底.ready()是如何实现更快的触发ready事件的呢，关键在jQuery.bindReady方法的实现里：  

对标准浏览器绑定：document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  
对IE浏览器绑定：document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

当然还有一些其他的关键技巧，现在完成的看下jQuery.bindReady的实现：  

// 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  
bindReady: function() { // jQuery.bindReady  
if ( readyList ) {  
    return;  
}  

readyList = jQuery._Deferred(); // 初始化ready异步事件句柄队列  

// Catch cases where $(document).ready() is called after the  
// browser event has already occurred.  
// 如果DOM已经完毕，立即调用jQuery.ready  
if ( document.readyState === &quot;complete&quot; ) {  
    // Handle it asynchronously to allow scripts the opportunity to delay ready  
    // 重要的是异步  
    return setTimeout( jQuery.ready, 1 );  
}  

// Mozilla, Opera and webkit nightlies currently support this event  
// DOM 2级事件模型，Mozilla, Opera, webkit等   
if ( document.addEventListener ) {  
    // Use the handy event callback  
    // 使用快速事件句柄  
    document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  

    // A fallback to window.onload, that will always work  
    // 再在window上绑定load事件句柄，这个句柄总是会执行  
    // 为什么同时绑定document window呢？我想是为了安全起见，防御性编码！  
    window.addEventListener( &quot;load&quot;, jQuery.ready, false );   

// If IE event model is used  
} else if ( document.attachEvent ) {  
    // ensure firing before onload,  
    // maybe late but safe also for iframes  
    // 同样onreadystatechange会在onload之前触发，但是对于iframe会有延迟但安全一定会触发  
    // 看看DOMContentLoaded的实现，是检测document.readyState的状态是否为complete，这里有些像ajax中的检测   
    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

    // A fallback to window.onload, that will always work  
    window.attachEvent( &quot;onload&quot;, jQuery.ready ); // 同样的安全起见，防御性编码！及时前边的所以hack技巧失败了，onload是最后的保障  

    // If IE and not a frame  
    // continually check to see if the document is ready  
    var toplevel = false;  

    try {  
        toplevel = window.frameElement == null; // 检查window的frameElement属性，看是否是顶层窗口  
    } catch(e) {}  

    // 做doScroll检测，如果在iframe中就不检测了，onreadystatechange对于ifame很可靠  
    if ( document.documentElement.doScroll &amp;&amp; toplevel ) {  
        doScrollCheck();   
        // 在doScrollCheck中，不断的（每隔1ms）执行document.documentElement.doScroll(&quot;left&quot;)，直到不抛出异常为止  
        // 这是IE下检测DOM ready的技巧  
        }  
    }  
},  

然后是完整的ready相关方法的分析，我剔除了其他无关的代码，保留了整体结构和相关方法：  

(function( window, undefined ) {  

    var jQuery = (function() {  

        // Define a local copy of jQuery  
        var jQuery = function( selector, context ) {  
                // The jQuery object is actually just the init constructor &apos;enhanced&apos;  
                var ret = new jQuery.fn.init( selector, context, rootjQuery );  
                return ret;  
            },  

            // A central reference to the root jQuery(document)  
            rootjQuery, // 包含了document的jQuery对象  

            // The deferred used on DOM ready  
            readyList, // ready事件处理函数队列  

            // The ready event handler  
            DOMContentLoaded, // DOM ready hack句柄，.ready()能早于.load()的关键所在  

        jQuery.fn = jQuery.prototype = {  
            constructor: jQuery,  
            init: function( selector, context, rootjQuery ) {  
                // HANDLE: $(function)  
                // Shortcut for document ready  
                // 如果函数，则认为是DOM ready句柄  
                if ( jQuery.isFunction( selector ) ) {  
                    return rootjQuery.ready( selector );  
                }  
            },  

            ready: function( fn ) {  
                // Attach the listeners  
                jQuery.bindReady(); // 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  

                // Add the callback  
                readyList.done( fn ); // 将ready句柄添加到ready异步句柄队列  

                return this;  
            }  
        };  

        // Give the init function the jQuery prototype for later instantiation  
        jQuery.fn.init.prototype = jQuery.fn;  

        jQuery.extend = jQuery.fn.extend = function() {};  

        jQuery.extend({  

            // Is the DOM ready to be used? Set to true once it occurs.  
            // DOM是否加载完毕  
            isReady: false,  

            // A counter to track how many items to wait for before  
            // the ready event fires. See #6781  
            // DOM加载完毕之前的等待次数  
            readyWait: 1,  

            // Hold (or release) the ready event  
            // 是否延迟触发DOM ready？在jQuery中没有任何地方有调用到holdReady，这是个遗留方法还是预留方法，有待继续研究。  
            // 因此在当前版本中，readyWait总是1，直到自减  
            holdReady: function( hold ) {  
                if ( hold ) { // 继续等待  
                    jQuery.readyWait++;  
                } else {  
                    jQuery.ready( true ); //   
                }  
            },  

            // Handle when the DOM is ready  
            // 判断DOM是否加载完毕，如果已完毕，调用DOM ready事件异步队列readyList，如果未完，每个1ms检查一次  
            ready: function( wait ) { // jQuery.ready  
                // Either a released hold or an DOMready/load event and not yet ready  
                // 条件1：wait === true &amp;&amp; !--jQuery.readyWait 还在等待加载完成，但是等待计数器jQuery.readyWait已经是0，  
                // 换句话说参数wait为true表示尝试一下看是否能开始调用readyList了，如果发现计数器jQuery.readyWait变成0，啥也不管了，开始调用吧  
                // 再换句话说，计数器已经是0了，开干吧  

                // 条件2：wait !== true &amp;&amp; !jQuery.isReady 明确的说不用了，即使DOM ready标记还是false  
                // 换句话说，及时DOM ready标记还是false，但是调用jQuery.ready的客户端认为不比再等了，可以开干了  
                if ( (wait === true &amp;&amp; !--jQuery.readyWait) || (wait !== true &amp;&amp; !jQuery.isReady) ) {  
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).  
                    // 检查document.body是否存在，这是特定于IE的检测，保证在IE中DOM ready事件能正确判断  
                    if ( !document.body ) {  
                        return setTimeout( jQuery.ready, 1 );  
                    }  

                    // Remember that the DOM is ready  
                    // 到这里，jQuery.isReady被强制为true  
                    // 在条件2中，如果jQuery.isReady为true，那么说明readyList的状态已经确定，添加到readyList中的函数会被立即执行  
                    // 如果jQuery.isReady为是false，那么接下来readyList中函数将被执行  
                    jQuery.isReady = true;  

                    // If a normal DOM Ready event fired, decrement, and wait if need be  
                    // 虽然上边的条件2的意思是，别管其他情况，调用方认为ready了，但是这里仍然做了防御性检测，如果等待计数器仍然大于1，结束ready调用  
                    // 如果这个条件成立，那么一定是哪里出问题了！  
                    // 在当前版本1.6.1中，这个判断永远不会成立，因为没有地方调用会使readyWait加一的holdReady  
                    if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {  
                        return;  
                    }  

                    // If there are functions bound, to execute  
                    // 调用DOM ready事件异步队列readyList，注意整理的参数亮了！  
                    // document指定了ready句柄的上下文，这样我们在执行ready事件句柄时this指向document  
                    // [ jQuery ]指定了ready事件句柄的第一个参数，这样即使调用$.noConflict()交出了$的控制权，我们依然可以将句柄的第一个参数命名为$，继续在句柄内部使用$符号  
                    // 如此的精致！赞叹之余，但不要在你的项目中也这么用，理解和维护将成为最大的难题。  
                    readyList.resolveWith( document, [ jQuery ] );  

                    // Trigger any bound ready events  
                    if ( jQuery.fn.trigger ) {  
                        // 触发ready事件，然后删除ready句柄，DOM ready事件只会生效一次，ready是个自定义事件  
                        jQuery( document ).trigger( &quot;ready&quot; ).unbind( &quot;ready&quot; );  
                    }  
                }  
            },  

            // 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  
            bindReady: function() { // jQuery.bindReady  
                if ( readyList ) {  
                    return;  
                }  

                readyList = jQuery._Deferred(); // 初始化ready异步事件句柄队列  

                // Catch cases where $(document).ready() is called after the  
                // browser event has already occurred.  
                // 如果DOM已经完毕，立即调用jQuery.ready  
                if ( document.readyState === &quot;complete&quot; ) {  
                    // Handle it asynchronously to allow scripts the opportunity to delay ready  
                    // 重要的是异步  
                    return setTimeout( jQuery.ready, 1 );  
                }  

                // Mozilla, Opera and webkit nightlies currently support this event  
                // DOM 2级事件模型，Mozilla, Opera, webkit等   
                if ( document.addEventListener ) {  
                    // Use the handy event callback  
                    // 使用快速事件句柄  
                    document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  

                    // A fallback to window.onload, that will always work  
                    // 再在window上绑定load事件句柄，这个句柄总是会执行  
                    // 为什么同时绑定document window呢？我想是为了安全起见，防御性编码！  
                    window.addEventListener( &quot;load&quot;, jQuery.ready, false );   

                // If IE event model is used  
                } else if ( document.attachEvent ) {  
                    // ensure firing before onload,  
                    // maybe late but safe also for iframes  
                    // 同样onreadystatechange会在onload之前触发，但是对于iframe会有延迟但安全一定会触发  
                    // 看看DOMContentLoaded的实现，是检测document.readyState的状态是否为complete，这里有些像ajax中的检测   
                    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

                    // A fallback to window.onload, that will always work  
                    window.attachEvent( &quot;onload&quot;, jQuery.ready ); // 同样的安全起见，防御性编码！及时前边的所以hack技巧失败了，onload是最后的保障  

                    // If IE and not a frame  
                    // continually check to see if the document is ready  
                    var toplevel = false;  

                    try {  
                        toplevel = window.frameElement == null; // 检查window的frameElement属性，看是否是顶层窗口  
                    } catch(e) {}  

                    // 做doScroll检测，如果在iframe中就不检测了，onreadystatechange对于ifame很可靠  
                    if ( document.documentElement.doScroll &amp;&amp; toplevel ) {  
                        doScrollCheck();   
                        // 在doScrollCheck中，不断的（每隔1ms）执行document.documentElement.doScroll(&quot;left&quot;)，直到不抛出异常为止  
                        // 这是IE下检测DOM ready的技巧  
                    }  
                }  
            },  
        });  

        // All jQuery objects should point back to these  
        rootjQuery = jQuery(document);  

        // Cleanup functions for the document ready method  
        // 构造浏览器加载完毕事件处理函数DOMContentLoaded，需要检测浏览器添加事件的方法  
        if ( document.addEventListener ) {  
            DOMContentLoaded = function() {  
                // document ready之后移除  
                document.removeEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  
                jQuery.ready();  
            };  

        } else if ( document.attachEvent ) {  
            DOMContentLoaded = function() {  
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).  
                // 确保body是存在的，IE会有一些延迟  
                if ( document.readyState === &quot;complete&quot; ) {  
                    // 先移除，难道浏览器重新渲染会再次触发onreadystatechange吗？  
                    document.detachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  
                    jQuery.ready();  
                }  
            };  
        }  

        // The DOM ready check for Internet Explorer  
        // 在IE里，每隔1ms检测IE浏览器的ready状态  
        function doScrollCheck() {  
            if ( jQuery.isReady ) {  
                return;  
            }  

            try {  
                // If IE is used, use the trick by Diego Perini  
                // http://javascript.nwbox.com/IEContentLoaded/  
                // 如果是IE，则使用该技巧来检测浏览器加载状态  
                document.documentElement.doScroll(&quot;left&quot;);  
            } catch(e) {  
                setTimeout( doScrollCheck, 1 );  
                return;  
            }  

            // and execute any waiting functions  
            // 执行其他的等待函数  
            jQuery.ready();  
        }  

        // Expose jQuery to the global object  
        return jQuery;  

    })();  

    // 见系列文章中关于异步队列的解析  
    jQuery.extend({  
        // Create a simple deferred (one callbacks list)  
        _Deferred: function() {},  

        // Full fledged deferred (two callbacks list)  
        Deferred: function( func ) {},  

        // Deferred helper  
        when: function( firstParam ) {}  
    });  

    // 见系列文章中关于事件的解析  
    jQuery.event = {  
        trigger: function( event, data, elem, onlyHandlers ) {},  

        handle: function( event ) {},  

        special: {  
            ready: {  
                // Make sure the ready event is setup  
                setup: jQuery.bindReady,  
                teardown: jQuery.noop  
            }  
        }  
    };  

    window.jQuery = window.$ = jQuery;  
})(window);  </code></pre><p>http://转载自：<a href="http://nuysoft.iteye.com/blog/1202422" target="_blank" rel="noopener">http://nuysoft.iteye.com/blog/1202422</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/jquery-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-10-e4-ba-8b-e4-bb-b6-e5-a4-84-e7-90-86-event-dom-ready-1/">
                jQuery源码分析-10事件处理-Event-DOM-ready
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>作者：nuysoft/JS攻城师/高云　QQ：47214707　EMail：nuysoft@gmail.com    
声明：本文为原创文章，如需转载，请注明来源并保留原文链接。     
后文预告：封装事件对象 便捷接口解析  

前记：  
这一章写的很用心，希望有所启发。因为排版的原因，阅读附件PDF更方便一些。  

jQuery源码分析系列大概已经写了60%，架构、构建jQuery对象、异步队列、浏览器测试、数据缓存、队列、事件模型、AJAX、动画、尺寸大小基本完结，这些比较难读也是我感兴趣的，剩余的部分有选择器、DOM遍历和操作、CSS和部分章节的补充，jQuery中的正则分析已有初稿但是内容太庞大还在拿捏怎么写合适，一些章节写的不是很满意有时间会做修改，详细的目录和计划可以去目录页参看 http://nuysoft.iteye.com/blog/1190542。  

JavaScript同其他语言一样，基础非常重要，仅仅会用框架和工具写一些WebApp是不能成为一名合格的JS工程师的，建议多读几次JavaScript权威指南，以我的经验与Java相比，JavaScript需要花费与Java相当的时间才能达到与Java相当的水平。  

jQuery完结之后计划写Java开源框架的源码解析，从Spring、Hibernate开始，有兴趣的同学可以一起研究。 

10.8    DOM ready  

初学jQuery时，很可能学到的第一个知识点就是.ready()，但是网络上流转的文章和API对此的解释或剖析，经常是模棱两可甚至是不准确或错误的，本节将详细的阐述.ready()的用法和原理，并纠正这些误区。  

10.8.1  如何使用.ready()  

.ready() 指定一个事件句柄，当DOM完全加载完成时执行  

虽然JavaScript提供了load事件，当页面渲染完成之后会执行这个函数，在所以元素加载完成之前，这个函数不会被调用，例如图像。但是在大多数情况下，只要DOM结构加载完，脚本就可以尽快运行。传递给.ready()的事件句柄在DOM准备好后立即执行，因此通常情况下，最好把绑定事件句柄和其他jQuery代码都到这里来。但是当脚本依赖于CSS样式属性时，一定要在脚本之前引入外部样式或内嵌样式的元素。  

如果代码依赖于需加载完的元素（例如，想获取一个图片的尺寸大小），应该用.load()事件代替，并把代码放到load事件句柄中。  

.ready()方法不同于&lt;body onload=&quot;&quot;&gt;属性。如果必须用load事件，那么就不要使用.ready()，或用.load()代替，把load事件句柄绑定到window或其他的具体元素上，例如图片。  

以下三个语法全部是等价的：  
$(document).ready(handler)  
$().ready(handler) (this is not recommended)  
$(handler)  

$(document).bind(&quot;ready&quot;, handler)的行为类似于ready方法，但有一个例外：如果ready事件已触发后，再尝试用.bind(&quot;ready&quot;)绑定的处理函数将不会被执行。而用以上三种方法绑定的句柄会被执行，无论是什么时候绑定的。  
.ready()方法只能在包含了document的jQuery上调用，因此选择器可以省略。  
.ready()方法典型的用法是使用一个匿名函数：  
$(document).ready(function() {  
  // Handler for .ready() called.  
});  
等价于：  
$(function() {  
 // Handler for .ready() called.  
});  

如果在DOM加载完毕之后调用.ready()，新的句柄将会立即执行。  

特别强调两点：  
1.  之所以花费篇幅来阐述.ready()如何使用（翻译的官网文档），是因为网络上的一些文章和中文API不准确甚至是错误的（应该是工具翻译的），所以需谨慎参考  
2.  .ready()的触发要早于.load()，但是不要完全迷信依赖，如果要获取或操作样式，或依赖于像图片这样的必须加载完成才能获取和操作的元素，就用&lt;body onload=&quot;&quot;&gt;或.load()  

10.8.2  源码分析  

到底.ready()是如何实现更快的触发ready事件的呢，关键在jQuery.bindReady方法的实现里：  

对标准浏览器绑定：document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  
对IE浏览器绑定：document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

当然还有一些其他的关键技巧，现在完成的看下jQuery.bindReady的实现：  

// 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  
bindReady: function() { // jQuery.bindReady  
if ( readyList ) {  
    return;  
}  

readyList = jQuery._Deferred(); // 初始化ready异步事件句柄队列  

// Catch cases where $(document).ready() is called after the  
// browser event has already occurred.  
// 如果DOM已经完毕，立即调用jQuery.ready  
if ( document.readyState === &quot;complete&quot; ) {  
    // Handle it asynchronously to allow scripts the opportunity to delay ready  
    // 重要的是异步  
    return setTimeout( jQuery.ready, 1 );  
}  

// Mozilla, Opera and webkit nightlies currently support this event  
// DOM 2级事件模型，Mozilla, Opera, webkit等   
if ( document.addEventListener ) {  
    // Use the handy event callback  
    // 使用快速事件句柄  
    document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  

    // A fallback to window.onload, that will always work  
    // 再在window上绑定load事件句柄，这个句柄总是会执行  
    // 为什么同时绑定document window呢？我想是为了安全起见，防御性编码！  
    window.addEventListener( &quot;load&quot;, jQuery.ready, false );   

// If IE event model is used  
} else if ( document.attachEvent ) {  
    // ensure firing before onload,  
    // maybe late but safe also for iframes  
    // 同样onreadystatechange会在onload之前触发，但是对于iframe会有延迟但安全一定会触发  
    // 看看DOMContentLoaded的实现，是检测document.readyState的状态是否为complete，这里有些像ajax中的检测   
    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

    // A fallback to window.onload, that will always work  
    window.attachEvent( &quot;onload&quot;, jQuery.ready ); // 同样的安全起见，防御性编码！及时前边的所以hack技巧失败了，onload是最后的保障  

    // If IE and not a frame  
    // continually check to see if the document is ready  
    var toplevel = false;  

    try {  
        toplevel = window.frameElement == null; // 检查window的frameElement属性，看是否是顶层窗口  
    } catch(e) {}  

    // 做doScroll检测，如果在iframe中就不检测了，onreadystatechange对于ifame很可靠  
    if ( document.documentElement.doScroll &amp;&amp; toplevel ) {  
        doScrollCheck();   
        // 在doScrollCheck中，不断的（每隔1ms）执行document.documentElement.doScroll(&quot;left&quot;)，直到不抛出异常为止  
        // 这是IE下检测DOM ready的技巧  
        }  
    }  
},  

然后是完整的ready相关方法的分析，我剔除了其他无关的代码，保留了整体结构和相关方法：  

(function( window, undefined ) {  

    var jQuery = (function() {  

        // Define a local copy of jQuery  
        var jQuery = function( selector, context ) {  
                // The jQuery object is actually just the init constructor &apos;enhanced&apos;  
                var ret = new jQuery.fn.init( selector, context, rootjQuery );  
                return ret;  
            },  

            // A central reference to the root jQuery(document)  
            rootjQuery, // 包含了document的jQuery对象  

            // The deferred used on DOM ready  
            readyList, // ready事件处理函数队列  

            // The ready event handler  
            DOMContentLoaded, // DOM ready hack句柄，.ready()能早于.load()的关键所在  

        jQuery.fn = jQuery.prototype = {  
            constructor: jQuery,  
            init: function( selector, context, rootjQuery ) {  
                // HANDLE: $(function)  
                // Shortcut for document ready  
                // 如果函数，则认为是DOM ready句柄  
                if ( jQuery.isFunction( selector ) ) {  
                    return rootjQuery.ready( selector );  
                }  
            },  

            ready: function( fn ) {  
                // Attach the listeners  
                jQuery.bindReady(); // 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  

                // Add the callback  
                readyList.done( fn ); // 将ready句柄添加到ready异步句柄队列  

                return this;  
            }  
        };  

        // Give the init function the jQuery prototype for later instantiation  
        jQuery.fn.init.prototype = jQuery.fn;  

        jQuery.extend = jQuery.fn.extend = function() {};  

        jQuery.extend({  

            // Is the DOM ready to be used? Set to true once it occurs.  
            // DOM是否加载完毕  
            isReady: false,  

            // A counter to track how many items to wait for before  
            // the ready event fires. See #6781  
            // DOM加载完毕之前的等待次数  
            readyWait: 1,  

            // Hold (or release) the ready event  
            // 是否延迟触发DOM ready？在jQuery中没有任何地方有调用到holdReady，这是个遗留方法还是预留方法，有待继续研究。  
            // 因此在当前版本中，readyWait总是1，直到自减  
            holdReady: function( hold ) {  
                if ( hold ) { // 继续等待  
                    jQuery.readyWait++;  
                } else {  
                    jQuery.ready( true ); //   
                }  
            },  

            // Handle when the DOM is ready  
            // 判断DOM是否加载完毕，如果已完毕，调用DOM ready事件异步队列readyList，如果未完，每个1ms检查一次  
            ready: function( wait ) { // jQuery.ready  
                // Either a released hold or an DOMready/load event and not yet ready  
                // 条件1：wait === true &amp;&amp; !--jQuery.readyWait 还在等待加载完成，但是等待计数器jQuery.readyWait已经是0，  
                // 换句话说参数wait为true表示尝试一下看是否能开始调用readyList了，如果发现计数器jQuery.readyWait变成0，啥也不管了，开始调用吧  
                // 再换句话说，计数器已经是0了，开干吧  

                // 条件2：wait !== true &amp;&amp; !jQuery.isReady 明确的说不用了，即使DOM ready标记还是false  
                // 换句话说，及时DOM ready标记还是false，但是调用jQuery.ready的客户端认为不比再等了，可以开干了  
                if ( (wait === true &amp;&amp; !--jQuery.readyWait) || (wait !== true &amp;&amp; !jQuery.isReady) ) {  
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).  
                    // 检查document.body是否存在，这是特定于IE的检测，保证在IE中DOM ready事件能正确判断  
                    if ( !document.body ) {  
                        return setTimeout( jQuery.ready, 1 );  
                    }  

                    // Remember that the DOM is ready  
                    // 到这里，jQuery.isReady被强制为true  
                    // 在条件2中，如果jQuery.isReady为true，那么说明readyList的状态已经确定，添加到readyList中的函数会被立即执行  
                    // 如果jQuery.isReady为是false，那么接下来readyList中函数将被执行  
                    jQuery.isReady = true;  

                    // If a normal DOM Ready event fired, decrement, and wait if need be  
                    // 虽然上边的条件2的意思是，别管其他情况，调用方认为ready了，但是这里仍然做了防御性检测，如果等待计数器仍然大于1，结束ready调用  
                    // 如果这个条件成立，那么一定是哪里出问题了！  
                    // 在当前版本1.6.1中，这个判断永远不会成立，因为没有地方调用会使readyWait加一的holdReady  
                    if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {  
                        return;  
                    }  

                    // If there are functions bound, to execute  
                    // 调用DOM ready事件异步队列readyList，注意整理的参数亮了！  
                    // document指定了ready句柄的上下文，这样我们在执行ready事件句柄时this指向document  
                    // [ jQuery ]指定了ready事件句柄的第一个参数，这样即使调用$.noConflict()交出了$的控制权，我们依然可以将句柄的第一个参数命名为$，继续在句柄内部使用$符号  
                    // 如此的精致！赞叹之余，但不要在你的项目中也这么用，理解和维护将成为最大的难题。  
                    readyList.resolveWith( document, [ jQuery ] );  

                    // Trigger any bound ready events  
                    if ( jQuery.fn.trigger ) {  
                        // 触发ready事件，然后删除ready句柄，DOM ready事件只会生效一次，ready是个自定义事件  
                        jQuery( document ).trigger( &quot;ready&quot; ).unbind( &quot;ready&quot; );  
                    }  
                }  
            },  

            // 绑定DOM ready监听器，跨浏览器，兼容标准浏览器和IE浏览器  
            bindReady: function() { // jQuery.bindReady  
                if ( readyList ) {  
                    return;  
                }  

                readyList = jQuery._Deferred(); // 初始化ready异步事件句柄队列  

                // Catch cases where $(document).ready() is called after the  
                // browser event has already occurred.  
                // 如果DOM已经完毕，立即调用jQuery.ready  
                if ( document.readyState === &quot;complete&quot; ) {  
                    // Handle it asynchronously to allow scripts the opportunity to delay ready  
                    // 重要的是异步  
                    return setTimeout( jQuery.ready, 1 );  
                }  

                // Mozilla, Opera and webkit nightlies currently support this event  
                // DOM 2级事件模型，Mozilla, Opera, webkit等   
                if ( document.addEventListener ) {  
                    // Use the handy event callback  
                    // 使用快速事件句柄  
                    document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  

                    // A fallback to window.onload, that will always work  
                    // 再在window上绑定load事件句柄，这个句柄总是会执行  
                    // 为什么同时绑定document window呢？我想是为了安全起见，防御性编码！  
                    window.addEventListener( &quot;load&quot;, jQuery.ready, false );   

                // If IE event model is used  
                } else if ( document.attachEvent ) {  
                    // ensure firing before onload,  
                    // maybe late but safe also for iframes  
                    // 同样onreadystatechange会在onload之前触发，但是对于iframe会有延迟但安全一定会触发  
                    // 看看DOMContentLoaded的实现，是检测document.readyState的状态是否为complete，这里有些像ajax中的检测   
                    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  

                    // A fallback to window.onload, that will always work  
                    window.attachEvent( &quot;onload&quot;, jQuery.ready ); // 同样的安全起见，防御性编码！及时前边的所以hack技巧失败了，onload是最后的保障  

                    // If IE and not a frame  
                    // continually check to see if the document is ready  
                    var toplevel = false;  

                    try {  
                        toplevel = window.frameElement == null; // 检查window的frameElement属性，看是否是顶层窗口  
                    } catch(e) {}  

                    // 做doScroll检测，如果在iframe中就不检测了，onreadystatechange对于ifame很可靠  
                    if ( document.documentElement.doScroll &amp;&amp; toplevel ) {  
                        doScrollCheck();   
                        // 在doScrollCheck中，不断的（每隔1ms）执行document.documentElement.doScroll(&quot;left&quot;)，直到不抛出异常为止  
                        // 这是IE下检测DOM ready的技巧  
                    }  
                }  
            },  
        });  

        // All jQuery objects should point back to these  
        rootjQuery = jQuery(document);  

        // Cleanup functions for the document ready method  
        // 构造浏览器加载完毕事件处理函数DOMContentLoaded，需要检测浏览器添加事件的方法  
        if ( document.addEventListener ) {  
            DOMContentLoaded = function() {  
                // document ready之后移除  
                document.removeEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );  
                jQuery.ready();  
            };  

        } else if ( document.attachEvent ) {  
            DOMContentLoaded = function() {  
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).  
                // 确保body是存在的，IE会有一些延迟  
                if ( document.readyState === &quot;complete&quot; ) {  
                    // 先移除，难道浏览器重新渲染会再次触发onreadystatechange吗？  
                    document.detachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );  
                    jQuery.ready();  
                }  
            };  
        }  

        // The DOM ready check for Internet Explorer  
        // 在IE里，每隔1ms检测IE浏览器的ready状态  
        function doScrollCheck() {  
            if ( jQuery.isReady ) {  
                return;  
            }  

            try {  
                // If IE is used, use the trick by Diego Perini  
                // http://javascript.nwbox.com/IEContentLoaded/  
                // 如果是IE，则使用该技巧来检测浏览器加载状态  
                document.documentElement.doScroll(&quot;left&quot;);  
            } catch(e) {  
                setTimeout( doScrollCheck, 1 );  
                return;  
            }  

            // and execute any waiting functions  
            // 执行其他的等待函数  
            jQuery.ready();  
        }  

        // Expose jQuery to the global object  
        return jQuery;  

    })();  

    // 见系列文章中关于异步队列的解析  
    jQuery.extend({  
        // Create a simple deferred (one callbacks list)  
        _Deferred: function() {},  

        // Full fledged deferred (two callbacks list)  
        Deferred: function( func ) {},  

        // Deferred helper  
        when: function( firstParam ) {}  
    });  

    // 见系列文章中关于事件的解析  
    jQuery.event = {  
        trigger: function( event, data, elem, onlyHandlers ) {},  

        handle: function( event ) {},  

        special: {  
            ready: {  
                // Make sure the ready event is setup  
                setup: jQuery.bindReady,  
                teardown: jQuery.noop  
            }  
        }  
    };  

    window.jQuery = window.$ = jQuery;  
})(window);  </code></pre><p>http://转载自：<a href="http://nuysoft.iteye.com/blog/1202422" target="_blank" rel="noopener">http://nuysoft.iteye.com/blog/1202422</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/jquery-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-jquery-e4-b8-ad-e7-9a-84-e5-be-aa-e7-8e-af-e6-8a-80-e5-b7-a7/">
                jQuery源码分析-jQuery中的循环技巧
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>// 简单的for-in（事件）  
for ( type in events ) {  

}  

// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度  
// 但是如果遍历HTMLCollection时，性能提升非常明显，因为每次访问HTMLCollection的属性，HTMLCollection都会内部匹配一次所有的节点  
for ( var j = 0, l = handlers.length; j &lt; l; j++ ) {  

}  

// 不比较下标，直接判断元素是否为true（强制类型转换）  
var elem;  
for ( var i = 0; elems[i]; i++ ) {  
    elem = elems[i];  
    // ...  
}  

// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--，保证不会因为数组下标的错误导致某些数组元素遍历不到  
for ( j = 0; j &lt; eventType.length; j++ ) {  
eventType.splice( j--, 1 );  
}  
for ( var i = 1; i &lt; results.length; i++ ) {  
    if ( results[i] === results[ i - 1 ] ) {  
        results.splice( i--, 1 );  
    }  
}  

// 迭代过程中尽可能减少遍历次数（事件），如果你能知道从哪里开始遍历的话，这里是pos  
for ( j = pos || 0; j &lt; eventType.length; j++ ) {  

}  

//倒序遍历（事件），减少了几个字符：循环条件判断，合并i自减和i取值，倒序遍历会有浏览器优化，稍微提升遍历速度  
for ( var i = this.props.length, prop; i; ) {  
    prop = this.props[ --i ];  
    event[ prop ] = originalEvent[ prop ];  
}  

// 倒序遍历，中规中矩，倒序会有浏览器优化，稍微提升遍历速度  
for ( j = tbody.length - 1; j &gt;= 0 ; --j ) {  
    if ( jQuery.nodeName( tbody[ j ], &quot;tbody&quot; ) &amp;&amp; !tbody[ j ].childNodes.length ) {  
        tbody[ j ].parentNode.removeChild( tbody[ j ] );  
    }  
}  

//不判断下标，直接判断元素（选择器）  
for ( i = 0; checkSet[i] != null; i++ ) {  
    if ( checkSet[i] &amp;&amp; (checkSet[i] === true || checkSet[i].nodeType === 1 &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {  
        results.push( set[i] );  
    }  
}  
for ( ; array[i]; i++ ) {  
    ret.push( array[i] );  
}  

// 不判断下标，取出元素然后判断元素（选择器）  
for ( var i = 0; (item = curLoop[i]) != null; i++ ) {  

}  

// 遍历DOM子元素  
for ( node = parent.firstChild; node; node = node.nextSibling ) {  
    if ( node.nodeType === 1 ) {  
        node.nodeIndex = ++count;  
    }  
}  

// 动态遍历DOM子元素（DOM遍历），dir参数表示元素的方向属性，如parentNode、nextSibling、previousSibling、lastChild和firstChild  
for ( ; cur; cur = cur[dir] ) {  
    if ( cur.nodeType === 1 &amp;&amp; ++num === result ) {  
        break;  
    }  
}  

// while检查下标i  
var i = promiseMethods.length;  
while( i-- ) {  
    obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];  
}  

// while检查元素  
while( (type = types[ i++ ]) ) {  

}  

// while遍历动态数组（AJAX），总是获取第一个元素，检查是否与特殊值相等，如果相等就从数组头部移除，直到遇到不相等的元素或数组为空  
while( dataTypes[ 0 ] === &quot;*&quot; ) {  
    dataTypes.shift();  
    if ( ct === undefined ) {  
        ct = s.mimeType || jqXHR.getResponseHeader( &quot;content-type&quot; );  
    }  
}  

// while遍历动态数组（异步队列），总是获取第一个元素，直到数组为空，或遇到值为undefined的元素  
while( callbacks[ 0 ] ) {  
    callbacks.shift().apply( context, args );  
}  

// while反复调用RegExp.exec（AJAX），能够否反复调是exec比re.test、String.match更加强大的原因，每次调用都将lastIndex属性设置到紧接着匹配字符串的字符位置  
while( ( match = rheaders.exec( responseHeadersString ) ) ) {  
    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ]; // 将响应头以key-value的方式存在responseHeaders中  
}  </code></pre><p>  <a href="http://转载自：http://nuysoft.iteye.com/blog/1217884" target="_blank" rel="noopener">http://转载自：http://nuysoft.iteye.com/blog/1217884</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/jquery-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-jquery-e4-b8-ad-e7-9a-84-e5-be-aa-e7-8e-af-e6-8a-80-e5-b7-a7-1/">
                jQuery源码分析-jQuery中的循环技巧
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <pre><code>// 简单的for-in（事件）  
for ( type in events ) {  

}  

// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度  
// 但是如果遍历HTMLCollection时，性能提升非常明显，因为每次访问HTMLCollection的属性，HTMLCollection都会内部匹配一次所有的节点  
for ( var j = 0, l = handlers.length; j &lt; l; j++ ) {  

}  

// 不比较下标，直接判断元素是否为true（强制类型转换）  
var elem;  
for ( var i = 0; elems[i]; i++ ) {  
    elem = elems[i];  
    // ...  
}  

// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--，保证不会因为数组下标的错误导致某些数组元素遍历不到  
for ( j = 0; j &lt; eventType.length; j++ ) {  
eventType.splice( j--, 1 );  
}  
for ( var i = 1; i &lt; results.length; i++ ) {  
    if ( results[i] === results[ i - 1 ] ) {  
        results.splice( i--, 1 );  
    }  
}  

// 迭代过程中尽可能减少遍历次数（事件），如果你能知道从哪里开始遍历的话，这里是pos  
for ( j = pos || 0; j &lt; eventType.length; j++ ) {  

}  

//倒序遍历（事件），减少了几个字符：循环条件判断，合并i自减和i取值，倒序遍历会有浏览器优化，稍微提升遍历速度  
for ( var i = this.props.length, prop; i; ) {  
    prop = this.props[ --i ];  
    event[ prop ] = originalEvent[ prop ];  
}  

// 倒序遍历，中规中矩，倒序会有浏览器优化，稍微提升遍历速度  
for ( j = tbody.length - 1; j &gt;= 0 ; --j ) {  
    if ( jQuery.nodeName( tbody[ j ], &quot;tbody&quot; ) &amp;&amp; !tbody[ j ].childNodes.length ) {  
        tbody[ j ].parentNode.removeChild( tbody[ j ] );  
    }  
}  

//不判断下标，直接判断元素（选择器）  
for ( i = 0; checkSet[i] != null; i++ ) {  
    if ( checkSet[i] &amp;&amp; (checkSet[i] === true || checkSet[i].nodeType === 1 &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {  
        results.push( set[i] );  
    }  
}  
for ( ; array[i]; i++ ) {  
    ret.push( array[i] );  
}  

// 不判断下标，取出元素然后判断元素（选择器）  
for ( var i = 0; (item = curLoop[i]) != null; i++ ) {  

}  

// 遍历DOM子元素  
for ( node = parent.firstChild; node; node = node.nextSibling ) {  
    if ( node.nodeType === 1 ) {  
        node.nodeIndex = ++count;  
    }  
}  

// 动态遍历DOM子元素（DOM遍历），dir参数表示元素的方向属性，如parentNode、nextSibling、previousSibling、lastChild和firstChild  
for ( ; cur; cur = cur[dir] ) {  
    if ( cur.nodeType === 1 &amp;&amp; ++num === result ) {  
        break;  
    }  
}  

// while检查下标i  
var i = promiseMethods.length;  
while( i-- ) {  
    obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];  
}  

// while检查元素  
while( (type = types[ i++ ]) ) {  

}  

// while遍历动态数组（AJAX），总是获取第一个元素，检查是否与特殊值相等，如果相等就从数组头部移除，直到遇到不相等的元素或数组为空  
while( dataTypes[ 0 ] === &quot;*&quot; ) {  
    dataTypes.shift();  
    if ( ct === undefined ) {  
        ct = s.mimeType || jqXHR.getResponseHeader( &quot;content-type&quot; );  
    }  
}  

// while遍历动态数组（异步队列），总是获取第一个元素，直到数组为空，或遇到值为undefined的元素  
while( callbacks[ 0 ] ) {  
    callbacks.shift().apply( context, args );  
}  

// while反复调用RegExp.exec（AJAX），能够否反复调是exec比re.test、String.match更加强大的原因，每次调用都将lastIndex属性设置到紧接着匹配字符串的字符位置  
while( ( match = rheaders.exec( responseHeadersString ) ) ) {  
    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ]; // 将响应头以key-value的方式存在responseHeaders中  
}  </code></pre><p>  <a href="http://转载自：http://nuysoft.iteye.com/blog/1217884" target="_blank" rel="noopener">http://转载自：http://nuysoft.iteye.com/blog/1217884</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/02/7/">
                Javascript正则表达式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-02</span>
            
            
            
                <span class="category">
                    <a href="/categories/转载/">转载</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>常用的数字正则（严格匹配）</p>
<pre><code>^[1-9]\d*$  匹配正整数  
^-[1-9]\d*$ 匹配负整数  
^-?[1-9]\d*$    匹配整数  
^[1-9]\d*|0$    匹配非负整数（正整数 + 0）  
^-[1-9]\d*|0$   匹配非正整数（负整数 + 0）  
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$  匹配正浮点数  
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$   匹配负浮点数  
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$     匹配浮点数  
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 匹配非负浮点数（正浮点数 + 0）  
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$    匹配非正浮点数（负浮点数 + 0） </code></pre><p>常用字符串正则</p>
<pre><code>^[A-Za-z]+$    匹配由26个英文字母组成的字符串    或 /^[a-z]+$/i
^[A-Z]+$    匹配由26个英文字母的大写组成的字符串    
^[a-z]+$    匹配由26个英文字母的小写组成的字符串    
^[A-Za-z0-9]+$    匹配由数字和26个英文字母组成的字符串    注意\w包含下划线_
^\w+$    匹配由数字、26个英文字母或者下划线组成的字符串    </code></pre><p>匹配中文字符</p>
<pre><code>普遍使用的正则是[\u4e00-\u9fa5]，但这个范围并不完整。例如：
/[\u4e00-\u9fa5]/.test( &apos;⻏&apos; ) // 测试部首⻏，返回false
根据Unicode 5.0版编码，要准确的判断一个中文字符要包括：
范围    含义    范围    含义
2E80-2EFF    CJK 部首补充    2F00-2FDF    康熙字典部首
3000-303F    CJK 符号和标点    31C0-31EF    CJK 笔画
3200-32FF    封闭式 CJK 文字和月份    3300-33FF    CJK 兼容
3400-4DBF    CJK 统一表意符号扩展 A    4DC0-4DFF    易经六十四卦符号
4E00-9FBF    CJK 统一表意符号    F900-FAFF    CJK 兼容象形文字
FE30-FE4F    CJK 兼容形式    FF00-FFEF    全角ASCII、全角标点
因此，正确的匹配中文字符正则表达式为：
var rcjk = /[\u2E80-\u2EFF\u2F00-\u2FDF\u3000-\u303F\u31C0-\u31EF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FBF\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]+/g;
如果不希望匹配标点、符号，在正则中去掉对应的范围即可：
3000-303F    CJK 符号和标点    FF00-FFEF    全角ASCII、全角标点</code></pre><p>匹配Email地址的正则表达式</p>
<pre><code>先介绍下Email的规则：local-part@domain
    local-part最长64，domain最长253，总长最长256
    local-part可以使用任意ASCII字符：
    大小写英文字母 a-z,A-Z
    数字 0-9
    字符 !#$%&amp;&apos;*+-/=?^_`{|}~
    字符 .不能是第一个和最后一个，不能连续出现两次
    但是有些邮件服务器会拒绝包含有特殊字符的邮件地址
    domain（域名）仅限于26个英文字母、10个数字、连词号-
    连词号-不能是第一个字符
    顶级域名（com、cn等）长度为2到6个
先说说网上流传的版本：
\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
()    莫名奇妙的分组，如果只分组不记录，可以使用(?:)
@\w    domain不能包含下划线_
\w+([-.]\w+)*    顶级域名不符合规则
修正如下：
var remail = /^([\w-_]+(?:\.[\w-_]+)*)@((?:[a-z0-9]+(?:-[a-zA-Z0-9]+)*)+\.[a-z]{2,6})$/i
remail.exec( &apos;nuysoft@gmail.com&apos; ) // &quot;nuysoft@gmail.com&quot;, &quot;nuysoft&quot;, &quot;gmail.com&quot;]
remail.exec( &apos;nuysoft@gmail.comcomcom&apos; ) // null
remail.exec( &apos;nuysoft@_gmail.com ) // null
修正后的正则有如下局限性：
    不支持中文邮箱、中文域名，之所以不在其中支持是因为我个人的爱好倾向，反感这类华而不实的玩意
    不支持特殊符号，避免非邮件服务器拒绝，如果需要，可以添加。
参考文章：
http://en.wikipedia.org/wiki/Email_address
http://baike.baidu.com/view/119298.htm</code></pre><p>匹配帐号是否合法</p>
<pre><code>var ruser = /\w{4,16}/</code></pre><p>匹配国内电话号码</p>
<pre><code>网上流传的版本很好用：
\d{3}-\d{8}|\d{4}-\d{7}
评注：匹配形式如 0511-4405222 或 021-87888822</code></pre><p>匹配腾讯QQ号</p>
<pre><code>网上流传的版本很好用：
[1-9]\d{5}(?!\d)
评注：中国邮政编码为6位数字</code></pre><p>匹配身份证</p>
<pre><code>先说说网上流传的版本：
\d{15}|\d{18}
d{15}
\d{18}    可以判断，但是有些粗糙 
从身份证可以解析出地址、生日、性别等，因此特别说明一下：
    身份证规则
中国的身份证为15位（一代）或18位（二代），区别在于二代证只是在一代证的第七位数字前加了19和在末尾加了一位验证码
    将15位升级为18位，并解析18位号码构成（地址、生日、性别）
代码如下：
function parseID(ID) {
    if ( ID.length == 15 ) {
        // 升级为18位
        ID = ID.substr( 0, 6 ) + &quot;19&quot; + ID.substr( 6 );
        // 前17位对应的系数
        var rank = [
                &quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot;, &quot;1&quot;, &quot;6&quot;, &quot;3&quot;, &quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot;
        ];
        // 前17为加权除以17后的余数对应的最后一位身份证号码
        var last = [
                &quot;1&quot;, &quot;0&quot;, &quot;X&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;
        ];
        // 加权和
        for ( var i = 0, sum = 0, len = ID.length; i &lt; len; i++)
            sum += ID[ i ] * rank[ i ];
        // 加上最后一位
        ID += last[ sum % 11 ];
    }
    if ( ID.length != 18 ) return null;

    var match = rid.exec( ID );
    return match ? {
        ID : ID,
        area : match[ 1 ],
        y : match[ 2 ],
        m : match[ 3 ],
        d : match[ 4 ],
        sex : match[ 5 ] % 2
    } : null;
}
限制：
    这里只是解析出了地址代码，如何将代码转换为实际地址请问度娘。
    返回对象中的sex为1（男）或0（女），并未做转换，如果页面显示需要，可以这样转换：sex ? &quot;男&quot; : &quot;女&quot; 
测试：
console.info( parseID( &quot;142327840821047&quot; ) );
console.info( parseID(&quot;142327198408210470&quot; ) );
参考资料：
http://baike.baidu.com/view/118340.htm#1</code></pre><p>匹配IP地址</p>
<pre><code>先说说网上流传的版本：
\d+\.\d+\.\d+\.\d+
\d    数字没有限制
修正如下：
var rip = /^(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])$/;
rip.test( &quot;192.168.1.1&quot; ) // true
rip.test( &quot;0.0.0.0&quot; ) // true
rip.test( &quot;255.255.255.255&quot; ) // true
rip.test( &quot;256.255.255.255&quot; ) // false
进一步增加分组：
var rip2 = /^([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])$/;
rip2.exec( &quot;192.168.1.1&quot; ) // [&quot;192.168.1.1&quot;, &quot;192&quot;, &quot;168&quot;, &quot;1&quot;, &quot;1&quot;]
rip2.exec( &quot;0.0.0.0&quot; ) // [&quot;0.0.0.0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;]
rip2.exec( &quot;255.255.255.255&quot; ) // [&quot;255.255.255.255&quot;, &quot;255&quot;, &quot;255&quot;, &quot;255&quot;, &quot;255&quot;]
rip2.exec( &quot;256.255.255.255&quot; ) // null</code></pre>
        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/9/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/11/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/09/02/hello-world/">Hello World</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/04/26/e6-95-b0-e7-bb-84-e5-af-b9-e8-b1-a1-e6-8e-92-e5-ba-8f-e6-8c-89-e7-85-a7jsonarray-e6-8e-92-e5-ba-8f/">数组对象排序按照JSONarray排序</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/04/26/e6-95-b0-e7-bb-84-e5-af-b9-e8-b1-a1-e6-8e-92-e5-ba-8f-e6-8c-89-e7-85-a7jsonarray-e6-8e-92-e5-ba-8f-1/">数组对象排序按照JSONarray排序</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/04/15/e5-89-8d-e7-ab-af-e7-ae-97-e6-b3-95-1/">前端算法</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/记录/转载/">转载</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/tutu/">tutu</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/迁移/">迁移</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/广告/">广告</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>